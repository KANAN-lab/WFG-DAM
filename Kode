function doGet() {
  return HtmlService.createTemplateFromFile('Index').evaluate()
  //return HtmlService.createTemplateFromFile('Builder10').evaluate()
    .addMetaTag('viewport', 'width=device-width , initial-scale=1')
    //.setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
    .setTitle('WFG');
}

// Function to get the HTML for a specific page
function loadPage(page) {
  return HtmlService.createTemplateFromFile(page).evaluate().getContent();  // Returns the HTML content for the page

}

// Fungsi untuk mengarahkan ke halaman utama (Main Page)
function redirectToMainPage() {
  return HtmlService.createHtmlOutputFromFile('Index')
    .setTitle('WFG');
}

function LoadchartapexSankey() {
  // Buka spreadsheet berdasarkan ID
  const ss = SpreadsheetApp.openById('Isi dengan id anda');
  const sheet = ss.getSheetByName('LANE STATUS');

  // Ambil data dari sheet
  const data = sheet.getDataRange().getValues();

  // Kembalikan data ke sisi klien
  return data;
}

/* Builder PRD */
/**
 * Fungsi utama untuk memproses data form dan menyimpannya ke Google Sheets.
 * @param {Object} formData - Data yang dikirim dari client-side.
 * @returns {String} - Tabel HTML yang menampilkan data yang telah disubmit.
 */
function processForm(formData) {
  try {
    const sheetId = 'Isi dengan id anda'; // Ganti dengan ID Sheet Anda
    const sheetName = 'Database';
    const ss = SpreadsheetApp.openById(sheetId);
    let sheet = ss.getSheetByName(sheetName);
    if (!sheet) {
      sheet = ss.insertSheet(sheetName);
    }
    
    // Header utama jika sheet kosong
    if (sheet.getLastRow() === 0) {
      const mainHeaders = ['Timestamp', 'Tanggal', 'Shift', 'Mesin', 'Size', 'Material', 'Stock Awal', 
                          '06:00-07:00', '07:00-08:00', '08:00-09:00', '09:00-10:00', 
                          '10:00-11:00', '11:00-12:00', 'Sisa Produksi Mesin', 'Total Pakai', 'Retur'];
      sheet.appendRow(mainHeaders);
      // Format header utama
      const headerRange = sheet.getRange(1, 1, 1, mainHeaders.length);
      headerRange.setBackground('#343a40').setFontColor('#ffffff').setFontWeight('bold');
    }
    
    // Ekstrak informasi umum dari form
    const TanggalInput = formData.tanggal; // Format input: yyyy-mm-dd
    const Shift = formData.shift;
    const Mesin = formData.mesin;
    const Size = formData.size;

    // Format Tanggal ke dd-MM-yyyy
    const Tanggal = formatDate(TanggalInput, "dd-MM-yyyy");
  
    // Format Timestamp sesuai WIB
    const timestamp = Utilities.formatDate(new Date(), SpreadsheetApp.getActive().getSpreadsheetTimeZone(), "dd-MM-yyyy HH:mm:ss");
    
    // Daftar material
    const materials = [
      "PULP LIGHTHOUSE", "SAP DIAPERS", "BOTTOM TISSUE", "NW INNERWAISTS SSS",
      "NW LEGCUFF SMS", "NWO AT", "NW OUTERWAIST SSS", "PRINTING SACHET",
      "PE FILM", "NW BACKSHEET SSS", "GLUE CORE", "GLUE CONSTRUCTION", 
      "GLUE ELASTIC", "ELASTIC 620DTEX", "NW ADL", "PRINTING BHP (SMALL)",
      "PRINTING BHP (MEDIUM)", "PRINTING BHP (LARGE)", "KARDUS BHP (SMALL)", 
      "KARDUS BHP (MEDIUM)", "KARDUS BHP (LARGE)", "ISOLASI (SACHET)",
      "ISOLASI (BAG)", "ISOLASI (REPACK)"
    ];
  
    // Rentang waktu berdasarkan Shift
    const timeRanges = {
      "1": ["06:00-07:00", "07:00-08:00", "08:00-09:00", "09:00-10:00", "10:00-11:00", "11:00-12:00"],
      "2": ["14:00-15:00", "15:00-16:00", "16:00-17:00", "17:00-18:00", "18:00-19:00", "19:00-20:00"],
      "3": ["22:00-23:00", "23:00-00:00", "00:00-01:00", "01:00-02:00", "02:00-03:00", "03:00-04:00"]
    };
  
    const selectedTimeRanges = timeRanges[Shift] || [];
  
    // Fungsi untuk mendapatkan Shift terakhir di sheet
    function getLastShift() {
      if (sheet.getLastRow() < 2) return null; // Tidak ada data selain header utama
      const lastDataRow = sheet.getLastRow();
      return sheet.getRange(lastDataRow, 3).getValue(); // Shift berada di kolom 3
    }
  
    const lastShift = getLastShift();
  
    // Jika Shift baru, tambahkan header shift
    if (lastShift !== Shift) {
      // Insert header shift
      const shiftHeader = `Shift ${Shift} - Data`;
      sheet.appendRow([shiftHeader]);
      // Merge cells untuk header shift
      const lastRow = sheet.getLastRow();
      sheet.getRange(lastRow, 1, 1, 15).merge().setBackground('#6c757d').setFontColor('#ffffff').setFontWeight('bold').setHorizontalAlignment('center');
      
      // Tambahkan header kolom data setelah header shift
      sheet.appendRow(['Timestamp', 'Tanggal', 'Shift', 'Mesin', 'Size', 'Material', 'Stock Awal', 
                      '06:00-07:00', '07:00-08:00', '08:00-09:00', '09:00-10:00', 
                      '10:00-11:00', '11:00-12:00', 'Sisa Produksi Mesin', 'Total Pakai', 'Retur']);
      const dataHeaderRange = sheet.getRange(sheet.getLastRow(), 1, 1, 15);
      dataHeaderRange.setBackground('#343a40').setFontColor('#ffffff').setFontWeight('bold');
    }
  
    // Loop melalui setiap material untuk menyimpan data
    materials.forEach(function(material) {
      const stockAwal = parseFloat(formData["stockAwal_" + material]) || 0;
      const sisa = parseFloat(formData["sisa_" + material]) || 0;
      const total = parseFloat(formData["total_" + material]) || 0;
      const retur = parseFloat(formData["retur_" + material]) || 0;
  
      // Mengumpulkan data per jam untuk setiap material
      const hours = selectedTimeRanges.map(function(time) {
        return parseFloat(formData[`${material}_${time}`]) || 0;
      });
  
      // Menyiapkan data baris untuk sheet
      const rowData = [timestamp, Tanggal, Shift, Mesin, Size, material, stockAwal].concat(hours, [sisa, total, retur]);
  
      // Append row
      sheet.appendRow(rowData);
      const appendedRow = sheet.getLastRow();
      const range = sheet.getRange(appendedRow, 1, 1, rowData.length);
      
      // Atur border untuk baris yang baru ditambahkan
      range.setBorder(true, true, true, true, true, true, "black", SpreadsheetApp.BorderStyle.SOLID);
    });
  
    // Tambahkan baris kosong untuk spasi antar pengiriman data
    sheet.appendRow(['','','','','','','','','','','','','','','']);
  
    // Membuat HTML tabel dari data yang dikirim untuk ditampilkan sebagai konfirmasi
    let htmlTable = `
      <h3 class="text-center">Hasil Pengiriman Laporan Pemakaian Material</h3>
      <div style="overflow-x:auto;">
        <table class="table table-bordered">
          <thead class="table-dark">
            <tr>
              <th>Material</th>
              <th>Stock Awal</th>
              ${selectedTimeRanges.map(time => `<th>${time}</th>`).join('')}
              <th>Sisa Produksi Mesin</th>
              <th>Total Pakai</th>
              <th>Retur</th>
            </tr>
          </thead>
          <tbody>
    `;
  
    materials.forEach(function(material) {
      const stockAwal = parseFloat(formData["stockAwal_" + material]) || 0;
      const sisa = parseFloat(formData["sisa_" + material]) || 0;
      const total = parseFloat(formData["total_" + material]) || 0;
      const retur = parseFloat(formData["retur_" + material]) || 0;
  
      const row = `
        <tr>
          <td>${material}</td>
          <td>${stockAwal}</td>
          ${selectedTimeRanges.map(time => `<td>${parseFloat(formData[`${material}_${time}`]) || 0}</td>`).join('')}
          <td>${sisa}</td>
          <td>${total}</td>
          <td>${retur}</td>
        </tr>
      `;
      htmlTable += row;
    });
  
    htmlTable += `
          </tbody>
        </table>
      </div>
    `;
  
    return htmlTable;
  } catch (error) {
    Logger.log(error);
    return `<p>Error: ${error.toString()}</p>`;
  }
}

/**
 * Fungsi untuk mengambil semua data dari sheet dan mengembalikannya sebagai tabel HTML.
 * @returns {String} - Tabel HTML yang menampilkan semua data.
 */
function getAllData() {
  try {
    const sheetId = 'Isi dengan id anda';
    const sheetName = 'Database';
    const ss = SpreadsheetApp.openById(sheetId);
    const sheet = ss.getSheetByName(sheetName);
    
    if (!sheet) return '<p>Tidak ada data yang tersedia.</p>';
    
    const data = sheet.getDataRange().getValues();
    if (data.length === 0) return '<p>Tidak ada data yang tersedia.</p>';
    
    // Mendapatkan indeks kolom yang akan ditampilkan (hapus 'Timestamp')
    const headers = data[0];
    const displayHeaders = headers.filter((header, index) => index !== 0); // Menghapus kolom 0 (Timestamp)
    
    let htmlTable = `
      <h3 class="text-center">Semua Data Laporan Pemakaian Material</h3>
      <div style="overflow-x:auto;">
        <table class="table table-bordered">
          <thead class="table-dark">
            <tr>
              ${displayHeaders.map(header => `<th>${header}</th>`).join('')}
            </tr>
          </thead>
          <tbody>
    `;
    
    // Mulai dari baris ke-2
    for (let i = 1; i < data.length; i++) {
      // Skip header shift rows
      if (data[i][0].toString().startsWith('Shift')) continue;
      
      // Filter data: hanya menampilkan kolom selain Timestamp
      const rowData = data[i].filter((cell, index) => index !== 0);
      
      // Format 'Tanggal' jika diperlukan (pastikan kolom 'Tanggal' berada di indeks yang benar)
      // Misalnya, jika 'Tanggal' adalah kolom ke-2 (index 1 sebelum filter)
      const tanggalIndex = 1; // Sesuaikan jika posisi 'Tanggal' berbeda
      if (rowData[tanggalIndex - 1]) { // Setelah filter, 'Tanggal' menjadi indeks 0
        rowData[tanggalIndex - 1] = formatDate(rowData[tanggalIndex - 1], "dd-MM-yyyy");
      }
      
      htmlTable += `<tr>${rowData.map(cell => `<td>${cell}</td>`).join('')}</tr>`;
    }
    
    htmlTable += `
          </tbody>
        </table>
      </div>
    `;
    
    return htmlTable;
    
  } catch (error) {
    Logger.log(error);
    return `<p>Error: ${error.toString()}</p>`;
  }
}

/**
 * Fungsi untuk mengambil data berdasarkan filter Shift, Mesin, dan Size.
 * @param {String} shift - Shift yang dipilih (1, 2, 3) atau kosong untuk semua shift.
 * @param {String} mesin - Mesin yang dipilih (1, 2, 3) atau kosong untuk semua mesin.
 * @param {String} size - Size yang dipilih (S, M, L, XL, XXL) atau kosong untuk semua size.
 * @returns {String} - Tabel HTML yang menampilkan data sesuai filter.
 */
function getFilteredData(shift, mesin, size) {
  try {
    const sheetId = 'Isi dengan id anda';
    const sheetName = 'Database';
    const ss = SpreadsheetApp.openById(sheetId);
    const sheet = ss.getSheetByName(sheetName);
    
    if (!sheet) return '<p>Tidak ada data yang tersedia.</p>';
    
    const data = sheet.getDataRange().getValues();
    if (data.length === 0) return '<p>Tidak ada data yang tersedia.</p>';
    
    // Mendapatkan indeks kolom yang akan ditampilkan (hapus 'Timestamp')
    const headers = data[0];
    const displayHeaders = headers.filter((header, index) => index !== 0); // Menghapus kolom 0 (Timestamp)
    
    let htmlTable = `
      <h3 class="text-center">Data Laporan Pemakaian Material</h3>
      <div style="overflow-x:auto;">
        <table class="table table-bordered">
          <thead class="table-dark">
            <tr>
              ${displayHeaders.map(header => `<th>${header}</th>`).join('')}
            </tr>
          </thead>
          <tbody>
    `;
    
    // Mulai dari baris ke-2
    for (let i = 1; i < data.length; i++) {
      // Skip header shift rows
      if (data[i][0].toString().startsWith('Shift')) continue;
      
      // Filter berdasarkan Shift, Mesin, dan Size
      const rowShift = data[i][2].toString();
      const rowMesin = data[i][3].toString();
      const rowSize = data[i][4].toString();
  
      const matchShift = shift ? (rowShift === shift) : true;
      const matchMesin = mesin ? (rowMesin === mesin) : true;
      const matchSize = size ? (rowSize === size) : true;
  
      if (matchShift && matchMesin && matchSize) {
        // Filter data: hanya menampilkan kolom selain Timestamp
        const rowData = data[i].filter((cell, index) => index !== 0);
        
        // Format 'Tanggal' jika diperlukan (pastikan kolom 'Tanggal' berada di indeks yang benar)
        // Misalnya, jika 'Tanggal' adalah kolom ke-2 (index 1 sebelum filter)
        const tanggalIndex = 1; // Sesuaikan jika posisi 'Tanggal' berbeda
        if (rowData[tanggalIndex - 1]) { // Setelah filter, 'Tanggal' menjadi indeks 0
          rowData[tanggalIndex - 1] = formatDate(rowData[tanggalIndex - 1], "dd-MM-yyyy");
        }
        
        htmlTable += `<tr>${rowData.map(cell => `<td>${cell}</td>`).join('')}</tr>`;
      }
    }
    
    htmlTable += `
          </tbody>
        </table>
      </div>
    `;
    
    if (!htmlTable.includes('<tr>')) {
      htmlTable = '<p>Tidak ada data yang sesuai dengan filter yang dipilih.</p>';
    }

    return htmlTable;

  } catch (error) {
    Logger.log(error);
    return `<p>Error: ${error.toString()}</p>`;
  }
}

/**
 * Fungsi untuk memformat tanggal sesuai dengan format yang diinginkan.
 * @param {String|Date} dateInput - Tanggal dalam format string atau objek Date.
 * @param {String} format - Format yang diinginkan, misalnya "dd-MM-yyyy".
 * @returns {String} - Tanggal yang diformat.
 */
function formatDate(dateInput, format) {
  if (!dateInput) return '';
  
  let dateObj;
  
  if (typeof dateInput === 'string') {
    // Parsing tanggal dari string
    dateObj = new Date(dateInput);
  } else if (dateInput instanceof Date) {
    dateObj = dateInput;
  } else {
    return '';
  }
  
  return Utilities.formatDate(dateObj, SpreadsheetApp.getActive().getSpreadsheetTimeZone(), format);
}



/**
 * INCLUDE HTML PARTS, EG. JAVASCRIPT, CSS, OTHER HTML FILES
 */
function include(filename) {
  return HtmlService.createHtmlOutputFromFile(filename).getContent();
}

function submitDataSO(data) {
  const sheetId = 'Isi dengan id anda';
  const sheetName = 'SO RAW';
  const sheet = SpreadsheetApp.openById(sheetId).getSheetByName(sheetName);
  
  // Menyisipkan data ke sheet
  sheet.getRange(sheet.getLastRow() + 1, 1, data.length, data[0].length).setValues(data);
}

function getDataByDateZoneAndSession(date, zoneFilter, sessionFilter) {
  const sheet = SpreadsheetApp.openById('Isi dengan id anda').getSheetByName('SO RAW');
  const data = sheet.getDataRange().getValues(); // Ambil semua data dari sheet
  
  const inputDate = new Date(date); // Konversi input tanggal dari pengguna
  
  // Filter data berdasarkan tanggal, zona, dan session
  const filteredData = data.filter(row => {
    let rowDateText = row[5];  // Asumsikan kolom F (indeks 5) berisi tanggal dan waktu
    let rowDate = new Date(rowDateText);
    const rowTime = rowDate.getHours(); // Ambil jam dari timestamp

    // Handle format tanggal yang tidak valid
    if (isNaN(rowDate)) {
      const parts = rowDateText.split('/');
      if (parts.length === 3) {
        const day = parseInt(parts[0], 10);
        const month = parseInt(parts[1], 10) - 1;
        const year = parseInt(parts[2], 10);
        rowDate = new Date(year, month, day);
      }
    }

    // Filter berdasarkan tanggal
    const isDateMatch = rowDate.toDateString() === inputDate.toDateString();

    // Filter berdasarkan zona
    const isZoneMatch = zoneFilter === '' || row[4].startsWith(zoneFilter); // Asumsikan kolom E (indeks 4) berisi zona

    // Filter berdasarkan session (morning atau afternoon)
    let isSessionMatch = false;
    if (sessionFilter === 'morning') {
      isSessionMatch = rowTime >= 1 && rowTime < 13; // Morning: 01:00 AM - 12:00 PM
    } else if (sessionFilter === 'afternoon') {
      isSessionMatch = rowTime >= 13 && rowTime < 24; // Afternoon: 01:00 PM - 12:00 AM
    }

    return isDateMatch && isZoneMatch && isSessionMatch;
  });

  // Ambil data dari kolom A-F (indeks 0-5) tanpa memotong kode zona
  const modifiedData = filteredData.map(row => row.slice(0, 6));
  
  return modifiedData; // Kembalikan data yang sudah difilter
}

function updateQuantityInSpreadsheetByUniqueCode(uniqueCode, newQuantity) {
  const sheet = SpreadsheetApp.openById('Isi dengan id anda').getSheetByName('SO RAW');
  const data = sheet.getDataRange().getValues();
  
  // Cari row berdasarkan seluruh isi unique code (kolom ZONE)
  const rowIndex = data.findIndex(row => row[4] === uniqueCode);
  
  if (rowIndex !== -1) {
    // Jika ditemukan, perbarui kolom QTY (kolom D)
    sheet.getRange(rowIndex + 1, 4).setValue(newQuantity); // Update kolom QTY
  } else {
    throw new Error('Unique code not found.');
  }
}

function getDataSO() {
  const sheet = SpreadsheetApp.openById('Isi dengan id anda').getSheetByName('SO RAW');
  const data = sheet.getDataRange().getValues(); // Fetch all data from the sheet
  
  const currentDate = new Date();
  const currentDateString = currentDate.toDateString();
  const currentHour = currentDate.getHours();

  // Determine the session based on the current time
  let session;
  if (currentHour >= 1 && currentHour < 13) {
    session = 'morning'; // Session 1: 01:00 AM - 12:00 PM
  } else if (currentHour >= 13 && currentHour < 24) {
    session = 'afternoon'; // Session 2: 01:00 PM - 12:00 AM
  } else {
    return {}; // If outside of work hours, return an empty object
  }
  
  const result = {};

  data.forEach(row => {
    const rowDate = new Date(row[5]).toDateString(); // Column F contains the date
    const rowTime = new Date(row[5]).getHours(); // Extract the hour from the timestamp
    const mid = row[1]; // Column B for MID
    const productName = row[2]; // Column C for Product Name
    let quantity = row[3]; // Column D for Quantity
    const zone = row[4]; // Column E for Zone
    const conv = getConv(productName); // Fetch the conversion rate

    // Filter data by current date and session
    if (rowDate === currentDateString) {
      if ((session === 'morning' && rowTime >= 1 && rowTime < 13) || 
          (session === 'afternoon' && rowTime >= 13 && rowTime < 24)) {
        
        // Apply the conversion based on the zone
        if (zone.startsWith("ZONAA") || zone.startsWith("ZONAB") || zone.startsWith("ZONAR")) {
          quantity *= conv;
        } else if (zone.startsWith("ZONAE")) {
          quantity *= 1;
        }

        // Aggregate the quantity per product name
        if (result[productName]) {
          result[productName] += quantity;
        } else {
          result[productName] = quantity;
        }
      }
    }
  });

  return result; // Return the aggregated resultsubmit
}

function getConv(productName) {
  const conversionTable = {
    'L1': 64,
    'M1': 64,
    'XL1': 49,
    'L28': 32,
    'M32': 32,
    'XL26': 32,
    'L8': 45,
    'XL7': 9,
    'L11': 56,
    'M11': 56,
    'XL11': 42
  };
  
  return conversionTable[productName] || 1; // Default conversion rate is 1 if not found
}

function submitDataWithRemarksAndSession(data, remarks, dateWithTime, session) {
  const sheet = SpreadsheetApp.openById('Isi dengan id anda').getSheetByName("SO FINAL");
  const existingData = sheet.getRange('A:B').getValues(); // Fetch date and session columns

  // Extract the date from dateWithTime (format: DD/MM/YYYY HH:MM:SS)
  const submittedDate = dateWithTime.split(' ')[0]; // Get only the date part

  // Check if data for the same date and session already exists
  const isDuplicate = existingData.some(row => {
    const existingDate = row[0].toString().split(' ')[1]; // Get date from the sheet
    const existingSession = row[1]; // Get session (morning/afternoon) from the sheet
    return existingDate === submittedDate && existingSession === session;
  });

  // If a duplicate is found, return this information
  if (isDuplicate) {
    return { isDuplicate: true, session: session };
  }

  // If no duplicate, append the new data
  let lastRow = sheet.getLastRow(); // Find the last row in the sheet
  
  lastRow += 3; // Add 3 blank rows before appending new data

  // Insert a new row with the date and session
  sheet.getRange(lastRow + 1, 1).setValue(`Date: ${dateWithTime}`);
  sheet.getRange(lastRow + 1, 2).setValue(session); // Insert the session (morning/afternoon)

  // Add column headers
  sheet.getRange(lastRow + 2, 1, 1, 6).setValues([["MID", "NAME", "CONV", "QTY SO", "QTY SAP", "DIFF SO-SAP"]]);

  // Insert the data into the sheet
  const dataRange = sheet.getRange(lastRow + 3, 1, data.length, 6);
  const dataValues = data.map(item => [item.MID, item.Name, item.CONV, item.qtySO, item.qtySAP, item.diffSO_SAP]);
  dataRange.setValues(dataValues);

  // Add a row for remarks after the data
  const remarksRowIndex = lastRow + data.length + 4; 
  sheet.getRange(remarksRowIndex, 1, 1, 6).merge();  // Merge the first 6 columns
  sheet.getRange(remarksRowIndex, 1).setValue(`Remarks: ${remarks}`);

  // Apply borders around the newly added data
  const totalRows = data.length + 3; // Include the date, session, and header rows
  const borderRange = sheet.getRange(lastRow + 1, 1, totalRows, 6);
  borderRange.setBorder(true, true, true, true, true, true);

  return { isDuplicate: false, session: session }; // Return success
}

function getDiffSoSapByDate(selectedDate) {
  const sheet = SpreadsheetApp.openById('Isi dengan id anda').getSheetByName('SO FINAL');
  const data = sheet.getDataRange().getValues(); // Get all data from the sheet

  const result = {};
  const targetDateString = `Date: ${selectedDate}`;  // Format the selected date string

  // Loop through the data to find the row with the selected date
  for (let i = 0; i < data.length; i++) {
    if (data[i][0] && data[i][0].toString().startsWith(targetDateString)) {
      // Find the header row (two rows after the date header)
      const headerRow = i + 1;
      for (let j = headerRow + 1; j < data.length; j++) {
        // Stop at the next date header or blank row
        if (!data[j][0] || data[j][0].toString().startsWith('Date:')) break;

        // Collect DIFF SO-SAP values (assuming 6th column is DIFF SO-SAP)
        const productName = data[j][1];  // Assuming second column is the product name
        const diffSoSap = data[j][5];    // Assuming sixth column is DIFF SO-SAP
        result[productName] = diffSoSap;
      }
      break; // Exit loop once the date has been found and data collected
    }
  }

  return result;  // Return the DIFF SO-SAP data for the selected date
}

function getDataSOWithRemarksByDate(selectedDate, session) {
  const sheet = SpreadsheetApp.openById('Isi dengan id anda').getSheetByName('SO FINAL');
  const dataRange = sheet.getRange(1, 1, sheet.getLastRow(), 6).getValues(); // Mengambil semua data

  const filteredData = [];
  let remarks = '';
  const targetDateString = `Date: ${selectedDate}`;  // Membentuk string untuk memeriksa tanggal
  
  // Looping untuk mencari baris yang cocok dengan tanggal dan sesi
  for (let i = 0; i < dataRange.length; i++) {
    const dateCell = dataRange[i][0] ? dataRange[i][0].toString() : '';  // Ambil nilai dari kolom pertama (Tanggal dan waktu)
    const sessionCell = dataRange[i][1] ? dataRange[i][1].toString().toLowerCase() : '';  // Ambil nilai dari kolom kedua (Sesi)

    // Memeriksa apakah tanggal dan sesi cocok
    if (dateCell.includes(targetDateString) && sessionCell.includes(session)) {
      // Ambil data setelah menemukan tanggal dan sesi yang cocok
      for (let j = i + 2; j < dataRange.length && dataRange[j][0] !== ''; j++) {
        filteredData.push(dataRange[j]);  // Simpan baris data yang relevan
      }

      // Ambil remarks dari dua baris setelah data selesai
      const remarksRowIndex = i + filteredData.length + 3;
      remarks = dataRange[remarksRowIndex] && dataRange[remarksRowIndex][0]
        ? dataRange[remarksRowIndex][0].replace('Remarks: ', '')
        : '';
      break;
    }
  }

  return {
    data: filteredData,
    remarks: remarks
  };
}

function getDiffPreviousByDate(selectedDate) {
  const sheet = SpreadsheetApp.openById('Isi dengan id anda').getSheetByName('SO FINAL');
  const dataRange = sheet.getRange(1, 1, sheet.getLastRow(), 6).getValues(); // Mengambil semua data dari A hingga F (kolom ke-6)
  
  const diffPreviousData = [];

  // Looping melalui semua baris di dataRange untuk mencari tanggal yang sesuai
  for (let i = 0; i < dataRange.length; i++) {
    // Memeriksa apakah ada baris dengan tanggal yang cocok dengan tanggal dari FILTER DIFF PREVIOUS
    if (dataRange[i][0].toString().includes(`Date: ${selectedDate}`)) {
      // Mengambil nilai "DIFF PREVIOUS" dari kolom F (kolom ke-6, indeks 5) setelah menemukan tanggal yang cocok
      for (let j = i + 2; j < dataRange.length && dataRange[j][0] !== ''; j++) {
        diffPreviousData.push(dataRange[j][5]); // Kolom F berada pada indeks ke-5
      }
      break;
    }
  }

  return {
    data: diffPreviousData
  };
}

function getChartData() {
  const sheet = SpreadsheetApp.openById('1ynFYdKg2XdAdTQWw_U52wf_dvPiJWHUCd09mcu37d8k').getSheetByName('Taker');
  const data = sheet.getDataRange().getValues();
  
  // Remove the header
  data.shift();

  // MID values to track
  const mids = ['L1', 'M1', 'XL1', 'L28', 'M32', 'XL26', 'L8', 'XL7', 'L11', 'M11', 'XL11'];
  const colors = ['rgba(255, 99, 132, 1)', 'rgba(54, 162, 235, 1)', 'rgba(255, 206, 86, 1)',
                  'rgba(75, 192, 192, 1)', 'rgba(153, 102, 255, 1)', 'rgba(255, 159, 64, 1)',
                  'rgba(199, 199, 199, 1)', 'rgba(83, 102, 255, 1)', 'rgba(23, 206, 86, 1)',
                  'rgba(200, 192, 132, 1)', 'rgba(199, 100, 64, 1)'];
  
  // Helper function to format date as 'dd-MM-yyyy'
  const formatDate = date => {
    if (date instanceof Date && !isNaN(date)) {
      return Utilities.formatDate(date, Session.getScriptTimeZone(), 'dd-MM-yyyy');
    }
    return null; // Ignore invalid dates
  };

  // Prepare an object to aggregate data by MID and date
  const dateData = mids.reduce((acc, mid) => {
    acc[mid] = {}; // Initialize empty object for each MID
    return acc;
  }, {});

  // Aggregate the quantities by MID and exact date
  data.forEach(row => {
    const mid = row[2]; // MID is in column C
    const quantity = row[3]; // Quantity is in column D
    const rawDate = new Date(row[5]); // Column F contains the date
    const formattedDate = formatDate(rawDate);

    if (formattedDate) {
      if (!dateData[mid][formattedDate]) {
        dateData[mid][formattedDate] = 0; // Initialize if not present
      }
      dateData[mid][formattedDate] += quantity; // Sum the quantities for each date
    }
  });

  // Extract all unique dates, sorted in chronological order
  const uniqueDates = [...new Set(data.map(row => formatDate(new Date(row[5]))).filter(date => date))]
                       .sort((a, b) => new Date(a.split('-').reverse().join('-')) - new Date(b.split('-').reverse().join('-')));

  // Create a dataset object for each MID
  const datasets = mids.map((mid, index) => {
    const quantities = uniqueDates.map(date => dateData[mid][date] || 0); // Use 0 if no data for that date

    return {
      label: mid,
      data: quantities,
      type: 'line',
      borderColor: colors[index],
      backgroundColor: colors[index].replace('1)', '0.2)'), // Adjust transparency
      borderWidth: 2
    };
  });

  // Combine all datasets into one data object
  return {
    labels: uniqueDates, // Use the formatted dates as labels
    datasets: datasets
  };
}

function getSheetData() {
  const sheet = SpreadsheetApp.openById('1ynFYdKg2XdAdTQWw_U52wf_dvPiJWHUCd09mcu37d8k').getSheetByName('Taker');
  
  // Get data starting from the third row (skipping the first two header rows)
  const dataRange = sheet.getRange(3, 1, sheet.getLastRow() - 2, sheet.getLastColumn());
  const data = dataRange.getValues(); // Fetch all data starting from the third row

  // Transform data into an array of objects
  const transformedData = data.map(row => {
    let waktu = '';

    // Check if row[5] contains a valid Date
    if (row[5] instanceof Date) {
      // Format the date and time for 'waktu'
      const dayFormatted = Utilities.formatDate(row[5], Session.getScriptTimeZone(), "dd-MM-yyyy"); // Format date
      const timeFormatted = Utilities.formatDate(row[5], Session.getScriptTimeZone(), "HH:mm:ss"); // Format time
      waktu = `${dayFormatted} ${timeFormatted}`; // Combine date and time into one string
    } else {
      waktu = 'Invalid time'; // Fallback in case 'row[5]' is not a valid Date
    }

    return {
      checker: row[0] || '',  // Assuming 'Checker' is in the first column
      gate: row[1] || '',     // Assuming 'Gate' is in the second column
      product: row[2] || '',  // Assuming 'Product' is in the third column
      quantity: row[3] || 0,  // Assuming 'Quantity' is in the fourth column (default to 0 if empty)
      waktu: waktu            // Formatted 'waktu' value (either a valid date/time or 'Invalid time')
    };
  });

  return transformedData;
}

function getDataByDateAndSession(selectedDate, session) {
  const sheet = SpreadsheetApp.openById('Isi dengan id anda').getSheetByName('SO RAW');
  const data = sheet.getDataRange().getValues();
  
  const inputDate = new Date(selectedDate);

  // Filter data based on the selected date and session
  const filteredData = data.filter(row => {
    const rowDate = new Date(row[5]);
    const isDateMatch = rowDate.toDateString() === inputDate.toDateString();

    const currentHour = new Date(row[5]).getHours();
    const isSessionMatch = (session === 'morning' && currentHour >= 1 && currentHour < 13) || 
                           (session === 'afternoon' && currentHour >= 13 && currentHour < 24);

    return isDateMatch && isSessionMatch;
  });

  const modifiedData = filteredData.map(row => {
    return {
      lane: row[0],             // Lane (e.g., 'LANE 1A')
      productName: row[2] || 'N/A', // Product name
      quantity: row[3],          // Quantity
      date: row[5]               // Date information
    };
  });

  return modifiedData;  // Return the filtered data
}

// Fungsi untuk memproses login
function processLogin(username, password) {
  // Daftar pengguna dan kata sandi
  var users = {
    "checker": "123",
    "admin": "123",
    "staff": "123"
  };
  
  // Cek apakah username dan password cocok
  if (users[username] && users[username] === password) {
    return 'success';
  } else {
    return 'failure';
  }
}


function getZoneData() {
  const sheet = SpreadsheetApp.openById('Isi dengan id anda').getSheetByName('SO RAW');
  const data = sheet.getDataRange().getValues();
  
  const zones = [];
  const currentTime = new Date(); // Get current date and time
  const currentDate = currentTime.toDateString(); // Get current date string
  const currentHour = currentTime.getHours(); // Get the current hour
  
  // Determine the session based on the current time
  let session;
  if (currentHour >= 1 && currentHour < 13) {
    session = 'morning'; // Session 1: 01:00 AM - 12:00 PM
  } else if (currentHour >= 13 && currentHour < 24) {
    session = 'afternoon'; // Session 2: 01:00 PM - 12:00 AM
  } else {
    session = 'out-of-hours'; // If outside of work hours
  }
  
  let hasValidData = false;  // Flag to track if we find matching data for the session

  // Iterate through the data and check for row[4] and row[5] conditions
  for (let i = 0; i < data.length; i++) {
    const rowValue = data[i][4].toString().substring(0, 5);  // Get first 5 characters of row[4]
    const rowDateTime = new Date(data[i][5]);  // Convert row[5] to a date object
    const rowDate = rowDateTime.toDateString();  // Get date part of row[5]
    const rowHour = rowDateTime.getHours();  // Get hour part of row[5]

    // Check if row[5] date matches current date and falls within the session
    if (rowDate === currentDate) {
      if (session === 'morning' && rowHour >= 1 && rowHour < 13) {
        hasValidData = true;
        if (rowValue === 'ZONAA' || rowValue === 'ZONAB' || rowValue === 'ZONAE') {
          zones.push(rowValue);
        }
      } else if (session === 'afternoon' && rowHour >= 13 && rowHour < 24) {
        hasValidData = true;
        if (rowValue === 'ZONAA' || rowValue === 'ZONAB' || rowValue === 'ZONAE') {
          zones.push(rowValue);
        }
      }
    }
  }

  // If no valid rows are found for the session, return an empty zones array
  return { zones, session, hasValidData };  // Include hasValidData in the response
}

/* Function INBOUND RAW */
// Fungsi untuk menghasilkan Unique ID
function generateUniqueId(zone) {
  const pattern = zone === 'A' ? 'ZONAA-xxxx-4xxx-yxxx-xxxxxxxxxxxx' : 'ZONAB-xxxx-4xxx-yxxx-xxxxxxxxxxxx';
  return pattern.replace(/[xy]/g, function(c) {
    const r = Math.random() * 16 | 0;
    const v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}

//BUILDER5
/**
 * Mendapatkan status terkini dari setiap lane berdasarkan zona.
 * @param {string} zone - Zona yang dipilih ('A' atau 'B').
 * @returns {Object} - Objek dengan key adalah Lane ID dan value adalah jumlah pallet, MID, dan setting saat ini.
 */
function getLaneStatus(zone) {
  const ss = SpreadsheetApp.openById('Isi dengan id anda'); // Ganti dengan ID Spreadsheet Anda
  const sheet = ss.getSheetByName('LANE STATUS'); // Ganti dengan nama sheet yang sesuai
  const data = sheet.getDataRange().getValues(); // Asumsi baris pertama adalah header

  const laneStatus = {};
  for (let i = 1; i < data.length; i++) {
    const row = data[i];
    const laneId = row[0];    // Kolom A: Lane ID
    const laneZone = row[1];  // Kolom B: Zona
    const currentPallet = row[2]; // Kolom C: Jumlah Pallet
    const currentMID = row[3]; // Kolom D: MID (Kolom tambahan yang menyimpan MID)
    const currentSetting = row[4]; // Kolom E: Setting (Kolom tambahan untuk setting)

    if (laneZone === zone) {
      laneStatus[laneId] = {
        currentPallet,
        currentMID,
        currentSetting
      };
    }
  }
  return laneStatus;
}

/**
 * Memproses data yang disubmit dari frontend.
 * @param {Object} data - Data yang dikirim dari frontend.
 * @returns {Object} - Respons dari backend.
 */
function submitDataInboundRawFullPallet(data) {
  const ss = SpreadsheetApp.openById('Isi dengan id anda'); // Ganti dengan ID Spreadsheet Anda
  const laneSheet = ss.getSheetByName('LANE STATUS'); // Sheet untuk status lane
  const logSheet = ss.getSheetByName('INBOUND RAW'); // Sheet untuk mencatat log
  const dataSheet = ss.getSheetByName('Data'); // Sheet untuk data form (opsional)

  // Destructuring data from the submission
  const { zone, mid, lane, setting, stopwatchTime } = data;

  // Validate the incoming data
  if (!zone || !mid || !lane || !setting) {
    return { success: false, message: 'Data tidak lengkap.' };
  }

  // Fetch the data from the LANE STATUS sheet
  const laneData = laneSheet.getDataRange().getValues();
  let targetRow = -1;
  let currentMID = ""; // To store the existing MID in the lane, if any

  // Search for the row that corresponds to the selected lane and zone
  for (let i = 1; i < laneData.length; i++) { // Start from 1 to skip the header row
    const row = laneData[i];
    const laneId = row[0];  // Lane ID (Column A)
    const laneZone = row[1];  // Zone (Column B)
    currentMID = row[3];  // MID (Column D)
    
    if (laneId === lane && laneZone === zone) {
      targetRow = i + 1;  // Store the target row index (+1 for getRange compatibility)
      break;
    }
  }

  // If the lane is not found in the LANE STATUS sheet, return an error
  if (targetRow === -1) {
    return { success: false, message: `Lane ${lane} tidak ditemukan di Zona ${zone}.` };
  }

  // Check if there is already a different MID assigned to the lane
  if (currentMID && currentMID !== mid) {
    return { success: false, message: `Lane ${lane} sudah memiliki MID ${currentMID}. Tidak bisa menambahkan MID yang berbeda (${mid}).` };
  }

  // Fetch the current pallet count and maximum pallet count
  const currentPallet = laneSheet.getRange(targetRow, 3).getValue();  // Column C: Current Pallet Count
  const maxPallet = getMaxPallet(lane);  // Get the max pallet count for the lane

  // Calculate the new pallet count after the addition
  const newPalletCount = currentPallet + parseInt(setting);

  // Check if the new pallet count exceeds the lane's capacity
  if (newPalletCount > maxPallet) {
    return { success: false, message: `Penambahan ${setting} pallet melebihi kapasitas Lane ${lane} (${currentPallet}/${maxPallet}).` };
  }

  // Update the pallet count, MID, and setting in the LANE STATUS sheet
  laneSheet.getRange(targetRow, 3).setValue(newPalletCount);  // Update the pallet count (Column C)
  laneSheet.getRange(targetRow, 4).setValue(mid);  // Update the MID (Column D)
  laneSheet.getRange(targetRow, 5).setValue(setting);  // Update the setting (Column E)

  // Tambahkan tanggal submit di Kolom F
  const submissionDate = Utilities.formatDate(new Date(), "GMT+7", "yyyy-MM-dd");
  laneSheet.getRange(targetRow, 6).setValue(submissionDate); // Kolom F: Tanggal Submit


  // Generate a unique ID for this submission
  const uniqueId = generateUniqueId(zone);

  // Log the submission in the INBOUND RAW sheet
  const date = Utilities.formatDate(new Date(), "GMT+7", "yyyy-MM-dd");
  const time = Utilities.formatDate(new Date(), "GMT+7", "HH:mm:ss");
  logSheet.appendRow([uniqueId, date, time, zone, mid, lane, setting, stopwatchTime]);

  // Optionally, add the data to another sheet for form data (if applicable)
  if (dataSheet) {
    dataSheet.appendRow([uniqueId, date, time, zone, mid, lane, setting, stopwatchTime]);
  }

  // Return a success response
  return { success: true, uniqueId, date, time };
}

/**
 * Fungsi untuk menghasilkan Unique ID
 * @param {string} zone - Zona ('A' atau 'B')
 * @returns {string} - Unique ID sesuai format
 */
function generateUniqueId(zone) {
  const pattern = zone === 'A' ? 'ZONAA-xxxx-4xxx-yxxx-xxxxxxxxxxxx' : 'ZONAB-xxxx-4xxx-yxxx-xxxxxxxxxxxx';
  return pattern.replace(/[xy]/g, function(c) {
    const r = Math.random() * 16 | 0;
    const v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}

/**
 * Menentukan kapasitas maksimal berdasarkan Lane ID.
 * @param {string} laneId - Lane ID (misalnya, '11A', '10B').
 * @returns {number} - Kapasitas maksimal pallet untuk lane tersebut.
 */
function getMaxPallet(laneId) {
  const specialLanesA = ['11A', '17A', '23A'];
  const specialLanesB = ['10B', '22B'];
  if (specialLanesA.includes(laneId) || specialLanesB.includes(laneId)) {
    return 30;
  }
  return 75;
}

function unlockForm() {
  // Buka kunci semua input form yang terkunci
  const formElements = document.querySelectorAll('#palletForm select, #palletForm input');
  formElements.forEach(element => {
    element.disabled = false; // Aktifkan kembali semua input yang sebelumnya terkunci
  });

  // Sembunyikan tombol unlock setelah diklik
  document.getElementById('unlockButton').style.display = 'none';
  
  // Kembalikan focus pada form
  document.getElementById('palletForm').focus();
}

/**
 * Retrieves lane status data from the specified Google Sheets spreadsheet.
 *
 * @return {Array} An array of lane status objects.
 */
function getLaneStatusData() {
  const spreadsheetId = 'Isi dengan id anda';
  const sheetName = 'LANE STATUS';
  
  // Open the spreadsheet and select the sheet
  const ss = SpreadsheetApp.openById(spreadsheetId);
  const sheet = ss.getSheetByName(sheetName);
  
  if (!sheet) {
    throw new Error(`Sheet "${sheetName}" not found in spreadsheet.`);
  }
  
  // Get all data from the sheet
  const data = sheet.getDataRange().getValues();
  
  // Extract headers
  const headers = data[0];
  
  // Define the MID values to filter
  const validMIDs = ['L1', 'M1', 'XL1', 'L28', 'M32', 'XL26', 'L8', 'XL7', 'L11', 'M11', 'XL11'];
  
  // Process data rows
  const laneStatusData = [];
  
  for (let i = 1; i < data.length; i++) { // Start from 1 to skip headers
    const row = data[i];
    const laneID = row[0];
    const zona = row[1];
    const quantity = row[2];
    const mid = row[3];
    const setting = row[4];
    const date = row[5];
    
    // Validate MID
    if (validMIDs.includes(mid)) {
      laneStatusData.push({
        laneID: laneID,
        zona: zona,
        quantity: quantity,
        mid: mid,
        setting: setting,
        date: Utilities.formatDate(new Date(date), Session.getScriptTimeZone(), 'yyyy-MM-dd')
      });
    }
  }
  
  return laneStatusData;
}




/**
 * Fungsi pembulatan kustom.
 * Jika desimal >= 0.4, bulatkan ke atas. Jika < 0.4, bulatkan ke bawah.
 *
 * @param {number} num - Angka yang akan dibulatkan.
 * @return {number} Angka yang telah dibulatkan.
 */
function customRound(num) {
  const floored = Math.floor(num);
  const decimal = num - floored;
  return decimal >= 0.4 ? floored + 1 : floored;
}

/**
 * Fungsi untuk mengambil data baru yang akan ditampilkan di tabel baru.
 * Mengambil data dari sheet "LANE STATUS", mengelompokkan berdasarkan MID (NAME PRODUCT),
 * menjumlahkan Quantity, dan menghitung ACTUAL STOCK / PALLET serta ACTUAL STOCK / BOX
 * dengan penyesuaian untuk Zona "E" atau "ECERAN" dan pembulatan kustom.
 *
 * @return {Array} Array of Arrays yang berisi [MID, NAME PRODUCT, ACTUAL STOCK / PALLET, ACTUAL STOCK / BOX]
 */
function getNewStockData() {
  // Definisikan urutan produk sesuai dengan nama produk di spreadsheet
  const orderedProducts = [
    "L11",
    "L1",
    "L28",
    "L8",
    "M11",
    "M1",
    "M32",
    "XL11",
    "XL1",
    "XL26",
    "XL7"
  ];

  // Definisikan mapping dari nama produk ke MID dan converter
  const productMappings = {
    "L11": { mid: "1150051", converter: 56 },
    "L1": { mid: "1050051", converter: 64 },
    "L28": { mid: "50055", converter: 32 },
    "L8": { mid: "50052", converter: 45 },
    "M11": { mid: "1150046", converter: 56 },
    "M1": { mid: "1050046", converter: 64 },
    "M32": { mid: "50050", converter: 32 },
    "XL11": { mid: "1150056", converter: 48 },
    "XL1": { mid: "1050056", converter: 49 },
    "XL26": { mid: "50060", converter: 32 },
    "XL7": { mid: "50057", converter: 45 } // Diperbarui dari 9 menjadi 45
  };

  // Inisialisasi map untuk menyimpan jumlah boxes per MID
  const stockMap = {};
  orderedProducts.forEach(productName => {
    stockMap[productName] = {
      boxes: 0
    };
  });

  // Buka sheet "LANE STATUS"
  const sheet = SpreadsheetApp.openById('Isi dengan id anda').getSheetByName('LANE STATUS');
  const data = sheet.getDataRange().getValues();

  // Iterasi melalui setiap baris data, mulai dari baris kedua jika ada header
  for (let i = 1; i < data.length; i++) {
    const row = data[i];
    
    const zona = row[1] ? row[1].toString().trim().toUpperCase() : ''; // Kolom B: Zona
    const productName = row[3] ? row[3].toString().trim() : ''; // Kolom D: MID (Nama Produk)
    const quantity = parseInt(row[2], 10) || 0; // Kolom C: Quantity

    if (orderedProducts.includes(productName)) {
      const mapping = productMappings[productName];
      if (!mapping) {
        // Jika mapping tidak ditemukan, lewati produk ini
        continue;
      }
      const converter = mapping.converter;

      if (zona === "E" || zona === "ECERAN") {
        // Jika Zona adalah E atau ECERAN, tambahkan ke boxes langsung
        stockMap[productName].boxes += quantity;
      } else {
        // Jika Zona lain (misalnya, A atau B), konversi pallets ke boxes dan tambahkan
        stockMap[productName].boxes += quantity * converter;
      }
    }
  }

  // Siapkan data untuk tabel baru sesuai urutan produk
  const newStockData = orderedProducts.map(productName => {
    const mapping = productMappings[productName];
    if (!mapping) {
      // Jika mapping tidak ditemukan, lewati produk ini
      return [productName, "Mapping Tidak Ditemukan", 0, 0];
    }

    const mid = mapping.mid;
    const converter = mapping.converter;
    const totalBoxes = stockMap[productName].boxes;
    const palletsUnrounded = totalBoxes / converter;
    const totalPallets = customRound(palletsUnrounded); // Pembulatan kustom

    // Pastikan data valid
    const validPallet = Number.isInteger(totalPallets) && totalPallets >= 0;
    const validBox = Number.isInteger(totalBoxes) && totalBoxes >= 0;

    if (validPallet && validBox) {
      return [mid, productName, totalPallets, totalBoxes];
    } else {
      // Jika data tidak valid, tetapkan nilai 0
      return [mid, productName, 0, 0];
    }
  });

  return newStockData;
}



/**
 * Fungsi sementara untuk mengatur kata sandi admin awal.
 * Jalankan fungsi ini sekali saja dan hapus setelahnya.
 */
/* 
function initializeAdminPassword() {
  var initialPassword = 'Yaitu'; // Ganti dengan kata sandi yang diinginkan
  setInitialPassword(initialPassword);
}
*/


const SALT = 'Yaitu'; // Ganti dengan nilai salt yang kuat dan acak

/**
 * Function to save the setting value with password verification
 * @param {string} settingValue - The setting value selected by the admin
 * @param {string} password - The admin password entered by the user
 * @returns {Object} - Result object indicating success or failure
 */
function saveSetting(settingValue, password) {
  try {
    // Verify the password
    if (!verifyPassword(password)) {
      return { success: false, message: 'Incorrect password. Access denied.' };
    }

    // Validate settingValue
    const validSettings = ['1', '2']; // Tambahkan nilai yang valid sesuai kebutuhan
    if (!validSettings.includes(settingValue)) {
      return { success: false, message: 'Invalid setting value.' };
    }

    var scriptProperties = PropertiesService.getScriptProperties();
    scriptProperties.setProperty('currentSetting', settingValue);
    return { success: true };
  } catch (error) {
    return { success: false, message: 'Failed to save setting: ' + error.message };
  }
}

/**
 * Function to get the current setting value
 * @returns {string} - The current setting value or empty string if not set
 */
function getSetting() {
  try {
    var scriptProperties = PropertiesService.getScriptProperties();
    var settingValue = scriptProperties.getProperty('currentSetting');
    return settingValue || ""; // Return empty string if not set
  } catch (error) {
    return "";
  }
}

/**
 * Function to verify the admin password
 * @param {string} password - The password to verify
 * @returns {boolean} - True if password is correct, false otherwise
 */
function verifyPassword(password) {
  var scriptProperties = PropertiesService.getScriptProperties();
  var storedHashedPassword = scriptProperties.getProperty('adminPasswordHash');

  if (!storedHashedPassword) {
    throw new Error('Admin password has not been set. Please set it manually.');
  }

  // Hash the provided password with salt and compare
  var saltedPassword = SALT + password;
  var hashedPassword = Utilities.base64Encode(Utilities.computeDigest(Utilities.DigestAlgorithm.SHA_256, saltedPassword));
  return hashedPassword === storedHashedPassword;
}

/**
 * Function to set the initial admin password
 * Run this function manually once to set the admin password
 * @param {string} initialPassword - The initial password to set
 */
function setInitialPassword(initialPassword) {
  var scriptProperties = PropertiesService.getScriptProperties();
  var saltedPassword = SALT + initialPassword;
  var hashedPassword = Utilities.base64Encode(Utilities.computeDigest(Utilities.DigestAlgorithm.SHA_256, saltedPassword));
  scriptProperties.setProperty('adminPasswordHash', hashedPassword);
}



/* Moving Lane Builder */
// Function to get the data for Lane Status
function getDataLaneStatus() {
  const ss = SpreadsheetApp.openById('Isi dengan id anda');
  const sheet = ss.getSheetByName('LANE STATUS');
  const data = sheet.getDataRange().getValues();

  // Helper function to format dates into 'YYYY-MM-DD' format
  function formatDateToString(date) {
    if (date instanceof Date) {
      return Utilities.formatDate(date, Session.getScriptTimeZone(), "yyyy-MM-dd");
    }
    return date; // If not a Date object, return as is
  }

  // Convert Date column to string format for easier display
  const formattedData = data.map(row => {
    if (row[5] instanceof Date) {
      row[5] = formatDateToString(row[5]); // Convert Date column (index 5) to string
    }
    return row;
  });

  return formattedData; // Return the formatted data
}

// Helper function to determine Max Pallet Based On Lane ID
function getMaxPallet(laneId) {
  const specialLanesA = ["11A", "17A", "23A"];
  const specialLanesB = ["10B", "22B"];
  if (specialLanesA.includes(laneId) || specialLanesB.includes(laneId)) {
    return 30;
  }
  return 75;
}

// Define mapping from MID to converter (Perbaikan sesuai Perintah 1)
const productMappings = {
  "L11": { converter: 56 },
  "L1": { converter: 64 },
  "L28": { converter: 32 },
  "L8": { converter: 45 },
  "M11": { converter: 56 },
  "M1": { converter: 64 },
  "M32": { converter: 32 },
  "XL11": { converter: 48 },
  "XL1": { converter: 49 },
  "XL26": { converter: 32 },
  "XL7": { converter: 45 } // Updated from 9 to 45
};

// Function to move data from Source to Target and log it to the "MOVING LOG" sheet
function moveDataWithLogging(sourceZona, sourceLane, targetZona, targetLane, transferQuantity, alasan = "") {
  try {
    const ss = SpreadsheetApp.openById('Isi dengan id anda'); // Replace with your Spreadsheet ID
    const sheet = ss.getSheetByName('LANE STATUS'); // Replace with your LANE STATUS sheet
    if (!sheet) {
      throw new Error('Sheet "LANE STATUS" not found.');
    }
    const data = sheet.getDataRange().getValues();
    
    let sourceRowIndex = -1;
    let targetRowIndex = -1;

    // Locate source and target rows
    for (let i = 1; i < data.length; i++) { // Start from 1 to skip header
      let row = data[i];
      if (row[0].trim().toUpperCase() === sourceLane.trim().toUpperCase() && row[1].trim().toUpperCase() === sourceZona.trim().toUpperCase()) {
        sourceRowIndex = i + 1; // Spreadsheet rows are 1-based
      }
      if (row[0].trim().toUpperCase() === targetLane.trim().toUpperCase() && row[1].trim().toUpperCase() === targetZona.trim().toUpperCase()) {
        targetRowIndex = i + 1;
      }
    }

    if (sourceRowIndex === -1) {
      throw new Error(`Source data not found for Zona ${sourceZona} and Lane ${sourceLane}.`);
    }

    if (targetRowIndex === -1) {
      throw new Error(`Target data not found for Zona ${targetZona} and Lane ${targetLane}.`);
    }

    // Get data from source
    const sourceData = data[sourceRowIndex - 1];
    let [laneSumber, zonaSumber, quantitySumber, midSumber, settingSumber, dateSumber] = sourceData;

    quantitySumber = parseInt(quantitySumber, 10);
    if (isNaN(quantitySumber) || quantitySumber <= 0) {
      throw new Error(`No Quantity data available to transfer from Zona ${sourceZona} and Lane ${sourceLane}.`);
    }

    // Validate transferQuantity
    transferQuantity = parseInt(transferQuantity, 10);
    if (isNaN(transferQuantity) || transferQuantity < 1) {
      throw new Error('Transfer Quantity must be valid.');
    }

    if (transferQuantity > quantitySumber) {
      throw new Error(`Transfer Quantity (${transferQuantity}) exceeds source Quantity (${quantitySumber}).`);
    }

    // Handle the case where source and target are the same
    if (
      sourceZona.trim().toUpperCase() === targetZona.trim().toUpperCase() &&
      sourceLane.trim().toUpperCase() === targetLane.trim().toUpperCase()
    ) {
      // Quantities remain the same; log the transfer
      const logSheet = ss.getSheetByName('MOVING LOG') || ss.insertSheet('MOVING LOG');
      
      // If log sheet is empty, add headers
      if (logSheet.getLastRow() === 0) {
        logSheet.appendRow(['Timestamp', 'Zona Sumber', 'Lane Sumber', 'Zona Target', 'Lane Target', 'Alasan', 'Lane', 'Zona', 'Quantity', 'MID', 'Setting', 'Date']);
      }

      // Log the transfer
      const timestamp = new Date();
      logSheet.appendRow([timestamp, sourceZona, sourceLane, targetZona, targetLane, alasan, sourceLane, sourceZona, transferQuantity, midSumber, settingSumber, dateSumber]);

      Logger.log('Transfer within the same lane and zone completed. Quantities remain unchanged.');
      return 'Transfer within the same lane and zone completed. Quantities remain unchanged.';
    }

    // **Penambahan Logika untuk Menolak Transfer dari E ke A/B**
    if (
      sourceZona.trim().toUpperCase() === 'E' &&
      (targetZona.trim().toUpperCase() === 'A' || targetZona.trim().toUpperCase() === 'B')
    ) {
      throw new Error('Pemindahan data dari Zona E ke Zona A/B tidak diizinkan.');
    }

    // Additional logic for transferring to a different zone (Command 5)
    let isDifferentZone = sourceZona.trim().toUpperCase() !== targetZona.trim().toUpperCase();
    if (isDifferentZone && alasan.trim() === "") {
      throw new Error('Transferring to a different zone requires a reason.');
    }

    // Get data from target
    const targetData = data[targetRowIndex - 1];
    let [laneTargetCheck, zonaTargetCheck, quantityTarget, midTarget, settingTarget, dateTarget] = targetData;

    quantityTarget = parseInt(quantityTarget, 10);
    if (isNaN(quantityTarget)) {
      quantityTarget = 0;
    }

    // Additional logic for conversion when transferring from A/B to E (Command 6)
    let conversionFactor = 1;
    let converted = false;
    if ((sourceZona.trim().toUpperCase() === 'A' || sourceZona.trim().toUpperCase() === 'B') && targetZona.trim().toUpperCase() === 'E') {
      // Find converter based on MID
      if (productMappings[midSumber]) {
        conversionFactor = productMappings[midSumber].converter;
        converted = true;
      } else {
        throw new Error(`No converter found for MID ${midSumber}.`);
      }
    }

    let actualTransferQuantity = transferQuantity;
    let actualTransferQuantityConverted = transferQuantity;

    if (converted) {
      actualTransferQuantityConverted = transferQuantity * conversionFactor;
    }

    // If MID in target is same as source, perform quantity addition
    if (midTarget && midTarget.trim().toUpperCase() === midSumber.trim().toUpperCase()) {
      // Determine max pallets in target lane
      const maxPallet = getMaxPallet(targetLane.trim().toUpperCase());

      // Calculate available capacity in target
      const availableCapacity = maxPallet - quantityTarget;

      if (availableCapacity <= 0) {
        throw new Error(`Target Lane ${targetLane} is full with Quantity ${quantityTarget}.`);
      }

      // Determine the actual transfer quantity
      const actualTransfer = Math.min(actualTransferQuantityConverted, availableCapacity);

      // Update Quantity in target
      const newQuantityTarget = quantityTarget + actualTransfer;
      sheet.getRange(targetRowIndex, 3).setValue(newQuantityTarget); // Quantity

      // If there's Setting and Date to transfer, update them accordingly
      sheet.getRange(targetRowIndex, 5).setValue(settingSumber); // Setting
      sheet.getRange(targetRowIndex, 6).setValue(dateSumber);    // Date

      // Calculate quantity to deduct from source
      let quantityToDeduct = converted ? Math.ceil(actualTransfer / conversionFactor) : transferQuantity;
      const newQuantitySumber = quantitySumber - quantityToDeduct;
      sheet.getRange(sourceRowIndex, 3).setValue(newQuantitySumber); // Quantity

      // If there's remaining quantity in source, retain Setting and Date
      if (newQuantitySumber > 0) {
        sheet.getRange(sourceRowIndex, 5).setValue(settingSumber); // Setting
        sheet.getRange(sourceRowIndex, 6).setValue(dateSumber);    // Date
      } else {
        // If no remaining quantity, clear MID, Setting, and Date
        sheet.getRange(sourceRowIndex, 3).setValue(0); // Quantity set to 0
        sheet.getRange(sourceRowIndex, 4).setValue(''); // Clear MID
        sheet.getRange(sourceRowIndex, 5).setValue(''); // Clear Setting
        sheet.getRange(sourceRowIndex, 6).setValue(''); // Clear Date
      }

      // Log the transfer
      const logSheet = ss.getSheetByName('MOVING LOG') || ss.insertSheet('MOVING LOG');
      
      // If log sheet is empty, add headers
      if (logSheet.getLastRow() === 0) {
        logSheet.appendRow(['Timestamp', 'Zona Sumber', 'Lane Sumber', 'Zona Target', 'Lane Target', 'Alasan', 'Lane', 'Zona', 'Quantity', 'MID', 'Setting', 'Date']);
      }

      // Log the transferred data
      const timestamp = new Date();
      logSheet.appendRow([timestamp, sourceZona, sourceLane, targetZona, targetLane, alasan, sourceLane, sourceZona, actualTransfer, midSumber, settingSumber, dateSumber]);

      Logger.log(`Data successfully transferred: ${actualTransfer} from Zona ${sourceZona} Lane ${sourceLane} to Zona ${targetZona} Lane ${targetLane}.`);
      
      return `Data successfully transferred: ${actualTransfer} from Zona ${sourceZona} Lane ${sourceLane} to Zona ${targetZona} Lane ${targetLane}.`;
    } else {
      // If MID in target is different or empty
      if (midTarget && midTarget.trim() !== "") {
        throw new Error(`Target Lane ${targetLane} already has a different MID. Cannot transfer data.`);
      }

      // Determine max pallets in target lane
      const maxPallet = getMaxPallet(targetLane.trim().toUpperCase());

      // Calculate available capacity in target
      const availableCapacity = maxPallet - quantityTarget;

      if (availableCapacity <= 0) {
        throw new Error(`Target Lane ${targetLane} is full with Quantity ${quantityTarget}.`);
      }

      // Determine the actual transfer quantity
      const actualTransfer = Math.min(actualTransferQuantityConverted, availableCapacity);

      // Update Quantity in target
      const newQuantityTarget = quantityTarget + actualTransfer;
      sheet.getRange(targetRowIndex, 3).setValue(newQuantityTarget); // Quantity

      // Update MID, Setting, and Date in target
      sheet.getRange(targetRowIndex, 4).setValue(midSumber);        // MID
      sheet.getRange(targetRowIndex, 5).setValue(settingSumber);    // Setting
      sheet.getRange(targetRowIndex, 6).setValue(dateSumber);       // Date

      // Calculate quantity to deduct from source
      let quantityToDeduct = converted ? Math.ceil(actualTransfer / conversionFactor) : transferQuantity;
      const newQuantitySumber = quantitySumber - quantityToDeduct;
      sheet.getRange(sourceRowIndex, 3).setValue(newQuantitySumber); // Quantity

      // If there's remaining quantity in source, retain Setting and Date
      if (newQuantitySumber > 0) {
        sheet.getRange(sourceRowIndex, 5).setValue(settingSumber); // Setting
        sheet.getRange(sourceRowIndex, 6).setValue(dateSumber);    // Date
      } else {
        // If no remaining quantity, clear MID, Setting, and Date
        sheet.getRange(sourceRowIndex, 3).setValue(0); // Quantity set to 0
        sheet.getRange(sourceRowIndex, 4).setValue(''); // Clear MID
        sheet.getRange(sourceRowIndex, 5).setValue(''); // Clear Setting
        sheet.getRange(sourceRowIndex, 6).setValue(''); // Clear Date
      }

      // Log the transfer
      const logSheet = ss.getSheetByName('MOVING LOG') || ss.insertSheet('MOVING LOG');
      
      // If log sheet is empty, add headers
      if (logSheet.getLastRow() === 0) {
        logSheet.appendRow(['Timestamp', 'Zona Sumber', 'Lane Sumber', 'Zona Target', 'Lane Target', 'Alasan', 'Lane', 'Zona', 'Quantity', 'MID', 'Setting', 'Date']);
      }

      // Log the transferred data
      const timestamp = new Date();
      logSheet.appendRow([timestamp, sourceZona, sourceLane, targetZona, targetLane, alasan, sourceLane, sourceZona, actualTransfer, midSumber, settingSumber, dateSumber]);

      Logger.log(`Data successfully transferred: ${actualTransfer} from Zona ${sourceZona} Lane ${sourceLane} to Zona ${targetZona} Lane ${targetLane}.`);

      return `Data successfully transferred: ${actualTransfer} from Zona ${sourceZona} Lane ${sourceLane} to Zona ${targetZona} Lane ${targetLane}.`;
    }
  } catch (error) {
    Logger.log(`Error in moveDataWithLogging: ${error.message}`);
    throw new Error(`Unable to transfer data: ${error.message}`);
  }
}




/* Builder10 */
// Konstanta untuk Spreadsheet
const SPREADSHEET_ID = 'Isi dengan id anda';
const SHEET_NAME = 'LANE STATUS';
const PICKING_LIST_SHEET_NAME = 'PICKING LIST'; // Nama baru sheet Picking List

/**
 * Fungsi untuk mendapatkan indeks kolom dengan ignore case dan trim
 */
function getColumnIndex(headers, columnName) {
  for (let i = 0; i < headers.length; i++) {
    if (headers[i].toString().trim().toLowerCase() === columnName.toLowerCase()) {
      return i;
    }
  }
  return -1;
}

/**
 * Fungsi utama untuk memproses outbound menggunakan FIFO dan membuat PICKING LIST
 * Dipanggil dari frontend
 * @param {Array} outboundOrders - Array objek {mid, lane, quantity}
 * @returns {Object} Result object dengan status dan pickingList atau error
 */
function processOutboundFIFO(outboundOrders) {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheet = ss.getSheetByName(SHEET_NAME);
  
  // Ambil semua data dari sheet
  const dataRange = sheet.getDataRange();
  const data = dataRange.getValues();
  
  // Asumsikan baris pertama adalah header
  const headers = data[0];
  
  const laneIndex = getColumnIndex(headers, 'Lane');
  const zonaIndex = getColumnIndex(headers, 'Zona');
  const quantityIndex = getColumnIndex(headers, 'Quantity');
  const midIndex = getColumnIndex(headers, 'MID');
  const dateIndex = getColumnIndex(headers, 'Date');
  
  // Log untuk debugging
  Logger.log('Lane Index: ' + laneIndex);
  Logger.log('Zona Index: ' + zonaIndex);
  Logger.log('Quantity Index: ' + quantityIndex);
  Logger.log('MID Index: ' + midIndex);
  Logger.log('Date Index: ' + dateIndex);
  
  if (laneIndex === -1 || zonaIndex === -1 || quantityIndex === -1 || midIndex === -1 || dateIndex === -1) {
    throw new Error('Pastikan sheet memiliki kolom "Lane", "Zona", "Quantity", "MID", dan "Date".');
  }
  
  const pickingList = [];
  const insufficientItems = [];
  const midsToClear = []; // Menyimpan nomor baris yang MID-nya akan dihapus
  
  outboundOrders.forEach(order => {
    const { mid, lane, quantity: orderQuantity } = order;
    let remainingQuantity = orderQuantity;
    
    // Temukan semua baris dengan MID dan Lane yang dipilih, Quantity >0
    const filteredItems = data.slice(1).filter(row => row[midIndex] === mid && row[laneIndex] === lane && row[quantityIndex] > 0)
                              .sort((a, b) => {
                                const dateA = a[dateIndex] ? new Date(a[dateIndex]) : new Date('9999-12-31');
                                const dateB = b[dateIndex] ? new Date(b[dateIndex]) : new Date('9999-12-31');
                                return dateA - dateB;
                              });
    
    if (filteredItems.length === 0) {
      insufficientItems.push({ mid, lane, shortage: remainingQuantity });
      return;
    }
    
    filteredItems.forEach(row => {
      if (remainingQuantity <= 0) return;
      
      const availableQuantity = row[quantityIndex];
      const deductQuantity = Math.min(availableQuantity, remainingQuantity);
      
      // Update Quantity di sheet
      const rowNumber = data.indexOf(row) + 1;
      const newQuantity = availableQuantity - deductQuantity;
      sheet.getRange(rowNumber, quantityIndex + 1).setValue(newQuantity);
      
      // Tambahkan ke PICKING LIST
      pickingList.push({
        lane: row[laneIndex],
        zona: row[zonaIndex],
        mid: mid,
        quantity: deductQuantity,
        date: row[dateIndex] ? Utilities.formatDate(new Date(row[dateIndex]), Session.getScriptTimeZone(), 'yyyy-MM-dd') : 'N/A'
      });
      
      remainingQuantity -= deductQuantity;
      
      // Jika Quantity sudah nol, tandai baris untuk menghapus MID
      if (newQuantity === 0) {
        midsToClear.push(rowNumber);
      }
    });
    
    if (remainingQuantity > 0) {
      insufficientItems.push({ mid, lane, shortage: remainingQuantity });
    }
  });
  
  // Tulis PICKING LIST ke sheet baru atau sheet yang sama
  let pickingSheet = ss.getSheetByName(PICKING_LIST_SHEET_NAME);
  if (!pickingSheet) {
    pickingSheet = ss.insertSheet(PICKING_LIST_SHEET_NAME);
    pickingSheet.appendRow(['Lane', 'Zona', 'MID', 'Quantity', 'Date']);
  } else {
    pickingSheet.clearContents();
    pickingSheet.appendRow(['Lane', 'Zona', 'MID', 'Quantity', 'Date']);
  }
  
  pickingList.forEach(item => {
    pickingSheet.appendRow([item.lane, item.zona, item.mid, item.quantity, item.date]);
  });
  
  // Hapus data MID pada baris yang Quantity-nya nol
  if (midsToClear.length > 0) {
    midsToClear.forEach(rowNumber => {
      sheet.getRange(rowNumber, midIndex + 1).setValue(''); // Menghapus nilai MID
    });
  }
  
  return {
    success: true,
    pickingList: pickingList,
    insufficientItems: insufficientItems
  };
}

/**
 * Fungsi untuk mengambil daftar unik MID dari spreadsheet
 * Dipanggil dari frontend
 * @returns {Array} Array unik MID
 */
function getMIDs() {
  const cache = CacheService.getScriptCache();
  const cachedMIDs = cache.get('uniqueMIDs');
  
  if (cachedMIDs) {
    return JSON.parse(cachedMIDs);
  }
  
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheet = ss.getSheetByName(SHEET_NAME);
  const dataRange = sheet.getDataRange();
  const data = dataRange.getValues();
  
  // Asumsikan baris pertama adalah header
  const headers = data[0];
  
  const midIndex = getColumnIndex(headers, 'MID');
  
  // Log untuk debugging
  Logger.log('MID Index: ' + midIndex);
  
  if (midIndex === -1) {
    throw new Error('Pastikan sheet memiliki kolom "MID".');
  }
  
  const mids = data.slice(1).map(row => row[midIndex]).filter(mid => mid && mid.toString().trim() !== '');
  const uniqueMIDs = [...new Set(mids)];
  
  // Cache the unique MIDs for 10 minutes
  cache.put('uniqueMIDs', JSON.stringify(uniqueMIDs), 600);
  
  return uniqueMIDs;
}

/**
 * Fungsi untuk mengambil daftar unik lanes untuk MID yang diberikan, diurutkan berdasarkan FIFO
 * Dipanggil dari frontend
 * @param {String} mid - MID yang dipilih
 * @returns {Array} Array objek lane dengan tanggal yang tersedia untuk MID tersebut, diurutkan berdasarkan FIFO
 */
function getLanesForMID(mid) {
  const cache = CacheService.getScriptCache();
  const cacheKey = `lanesForMID_${mid}`;
  const cachedLanes = cache.get(cacheKey);
  
  if (cachedLanes) {
    return JSON.parse(cachedLanes);
  }
  
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheet = ss.getSheetByName(SHEET_NAME);
  const dataRange = sheet.getDataRange();
  const data = dataRange.getValues();
  
  // Asumsikan baris pertama adalah header
  const headers = data[0];
  
  const laneIndex = getColumnIndex(headers, 'Lane');
  const midIndex = getColumnIndex(headers, 'MID');
  const quantityIndex = getColumnIndex(headers, 'Quantity');
  const dateIndex = getColumnIndex(headers, 'Date');
  
  if (laneIndex === -1 || midIndex === -1 || dateIndex === -1 || quantityIndex === -1) {
    throw new Error('Pastikan sheet memiliki kolom "Lane", "MID", "Quantity", dan "Date".');
  }
  
  // Filter rows dengan MID dan Quantity >0
  const filteredRows = data.slice(1).filter(row => row[midIndex] === mid && row[quantityIndex] > 0);
  
  // Sort berdasarkan Date ascending (FIFO)
  filteredRows.sort((a, b) => {
    const dateA = rowHasDate(a, dateIndex) ? new Date(a[dateIndex]) : new Date('9999-12-31');
    const dateB = rowHasDate(b, dateIndex) ? new Date(b[dateIndex]) : new Date('9999-12-31');
    return dateA - dateB;
  });
  
  // Membuat objek untuk menyimpan Lane dan tanggal pertama kali muncul (FIFO)
  const laneDateMap = {};
  filteredRows.forEach(row => {
    const lane = row[laneIndex];
    const date = row[dateIndex] ? Utilities.formatDate(new Date(row[dateIndex]), Session.getScriptTimeZone(), 'yyyy-MM-dd') : 'N/A';
    if (!laneDateMap[lane]) {
      laneDateMap[lane] = date;
    }
  });
  
  // Extract unique lanes dengan tanggal
  const lanesWithDates = Object.keys(laneDateMap).map(lane => ({
    lane: lane,
    date: laneDateMap[lane]
  }));
  
  // Cache the lanes for this MID for 10 minutes
  cache.put(cacheKey, JSON.stringify(lanesWithDates), 600);
  
  return lanesWithDates;
}

/**
 * Fungsi untuk mengambil Quantity yang tersedia untuk MID dan Lane tertentu
 * Dipanggil dari frontend
 * @param {String} mid - MID yang dipilih
 * @param {String} lane - Lane yang dipilih
 * @returns {Number} Quantity yang tersedia
 */
function getAvailableQuantity(mid, lane) {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheet = ss.getSheetByName(SHEET_NAME);
  const dataRange = sheet.getDataRange();
  const data = dataRange.getValues();
  
  // Asumsikan baris pertama adalah header
  const headers = data[0];
  
  const laneIndex = getColumnIndex(headers, 'Lane');
  const midIndex = getColumnIndex(headers, 'MID');
  const quantityIndex = getColumnIndex(headers, 'Quantity');
  
  if (laneIndex === -1 || midIndex === -1 || quantityIndex === -1) {
    throw new Error('Pastikan sheet memiliki kolom "Lane", "MID", dan "Quantity".');
  }
  
  // Cari baris yang sesuai dengan MID dan Lane
  const matchingRows = data.slice(1).filter(row => row[midIndex] === mid && row[laneIndex] === lane);
  
  // Jumlahkan Quantity yang tersedia
  const totalAvailable = matchingRows.reduce((acc, row) => acc + row[quantityIndex], 0);
  
  return totalAvailable;
}

/**
 * Helper function untuk memeriksa apakah baris memiliki tanggal
 */
function rowHasDate(row, dateIndex) {
  return row[dateIndex] && row[dateIndex].toString().trim() !== '';
}

/**
 * Fungsi untuk mengembalikan halaman HTML utama
 */
function getMainPage() {
  return HtmlService.createHtmlOutputFromFile('Index')
    .setTitle('Outbound FMCG')
    .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
}


/* Builder SYNC */
/**
 * Fungsi utama untuk menyinkronkan data dari "SO RAW" ke "LANE STATUS"
 * @param {string} selectedSession - Sesi yang dipilih oleh pengguna ('morning' atau 'afternoon')
 */
function synchronizeData(selectedSession) {
  const ss = SpreadsheetApp.openById("Isi dengan id anda"); // ID Spreadsheet Anda
  const soRawSheet = ss.getSheetByName("SO RAW");
  const laneStatusSheet = ss.getSheetByName("LANE STATUS");
  
  if (!soRawSheet || !laneStatusSheet) {
    throw new Error("Pastikan kedua sheet 'SO RAW' dan 'LANE STATUS' ada di spreadsheet.");
  }
  
  // Mengambil semua data dari "SO RAW" (tanpa header)
  const soRawData = soRawSheet.getDataRange().getValues();
  
  // Mengambil semua data dari "LANE STATUS" (dengan header)
  const laneStatusData = laneStatusSheet.getDataRange().getValues();
  
  // Mendapatkan header dari "LANE STATUS" dan membuat mapping indeks kolom
  const laneStatusHeader = laneStatusData[0].map(header => header.toString().trim().toLowerCase());
  const laneIdxStatus = laneStatusHeader.indexOf("lane");
  const quantityIdxStatus = laneStatusHeader.indexOf("quantity");
  const midIdxStatus = laneStatusHeader.indexOf("mid");
  
  if (laneIdxStatus === -1 || quantityIdxStatus === -1 || midIdxStatus === -1) {
    throw new Error("Pastikan sheet 'LANE STATUS' memiliki kolom 'Lane', 'Quantity', dan 'MID'.");
  }
  
  // Membuat mapping lane di "LANE STATUS" untuk akses cepat
  const laneStatusMap = {};
  for (let i = 1; i < laneStatusData.length; i++) {
    const laneName = laneStatusData[i][laneIdxStatus].toString().trim();
    if (laneName) {
      laneStatusMap[laneName] = i; // Menyimpan indeks baris (0-based)
    }
  }
  
  // Mendapatkan tanggal hari ini dalam format "dd/MM/yyyy"
  const now = new Date();
  const timeZone = ss.getSpreadsheetTimeZone();
  const todayStr = Utilities.formatDate(now, timeZone, "dd/MM/yyyy");
  
  // Menentukan sesi berdasarkan pilihan pengguna
  let session = selectedSession;
  if (!session) {
    const currentHour = now.getHours();
    if (currentHour >= 1 && currentHour < 13) {
      session = 'morning'; // Session 1: 01:00 AM - 12:59 PM
    } else if (currentHour >= 13 && currentHour < 24) {
      session = 'afternoon'; // Session 2: 01:00 PM - 11:59 PM
    } else {
      return "Skrip hanya berjalan antara 01:00 AM hingga 11:59 PM.";
    }
  }
  
  // Mendapatkan waktu batasan sesi
  let sessionStartHour, sessionEndHour;
  if (session === 'morning') {
    sessionStartHour = 1;
    sessionEndHour = 13; // 12:59 PM
  } else if (session === 'afternoon') {
    sessionStartHour = 13;
    sessionEndHour = 24; // 11:59 PM
  } else {
    throw new Error("Sesi yang dipilih tidak valid. Pilih 'morning' atau 'afternoon'.");
  }
  
  // Membuat mapping dari nama lane di "SO RAW" ke nama lane di "LANE STATUS"
  const laneMapping = getLaneMapping();
  
  // Menyiapkan array untuk perubahan Quantity dan MID
  const quantityUpdates = [];
  const midUpdates = [];
  
  // Mengiterasi data dari "SO RAW"
  for (let i = 0; i < soRawData.length; i++) { // Mulai dari 0 karena tidak ada header
    const row = soRawData[i];
    const soRawLane = row[0].toString().trim(); // Kolom A: Lane
    const soRawMID = row[2].toString().trim();  // Kolom C: MID
    const soRawQuantity = row[3];              // Kolom D: Quantity
    const soRawDate = row[5];                  // Kolom F: Date
    
    // Mengubah nama lane ke format "LANE STATUS" menggunakan mapping
    const mappedLane = laneMapping[soRawLane];
    if (!mappedLane) {
      Logger.log(`Tidak ada mapping untuk lane: ${soRawLane}`);
      continue; // Lewati jika tidak ada mapping
    }
    
    // Memeriksa apakah lane ada di "LANE STATUS"
    const laneStatusRow = laneStatusMap[mappedLane];
    if (laneStatusRow === undefined) {
      Logger.log(`Tidak ditemukan lane di 'LANE STATUS' untuk: ${mappedLane}`);
      continue; // Lewati jika lane tidak ditemukan
    }
    
    // Memeriksa tanggal dan sesi dari "SO RAW"
    const soRawDateObj = new Date(soRawDate);
    if (isNaN(soRawDateObj)) {
      Logger.log(`Tanggal tidak valid untuk lane: ${soRawLane} pada baris ${i + 1}`);
      continue; // Lewati jika tanggal tidak valid
    }
    
    const soRawDateStr = Utilities.formatDate(soRawDateObj, timeZone, "dd/MM/yyyy");
    const soRawHour = soRawDateObj.getHours();
    
    // Tentukan sesi dari data
    let dataSession;
    if (soRawHour >= 1 && soRawHour < 13) {
      dataSession = 'morning';
    } else if (soRawHour >= 13 && soRawHour < 24) {
      dataSession = 'afternoon';
    } else {
      dataSession = 'unknown';
    }
    
    // Hanya proses data yang sesuai dengan sesi yang dipilih dan tanggal hari ini
    if (soRawDateStr === todayStr && dataSession === session) {
      // Menyimpan perubahan
      quantityUpdates.push({ row: laneStatusRow + 1, value: soRawQuantity });
      midUpdates.push({ row: laneStatusRow + 1, value: soRawMID });
    }
  }
  
  // Melakukan batch update untuk Quantity
  if (quantityUpdates.length > 0) {
    const quantityRange = laneStatusSheet.getRange(2, quantityIdxStatus + 1, laneStatusData.length - 1, 1);
    const quantityValues = quantityRange.getValues();
    quantityUpdates.forEach(update => {
      quantityValues[update.row - 2][0] = update.value;
    });
    quantityRange.setValues(quantityValues);
  }
  
  // Melakukan batch update untuk MID
  if (midUpdates.length > 0) {
    const midRange = laneStatusSheet.getRange(2, midIdxStatus + 1, laneStatusData.length - 1, 1);
    const midValues = midRange.getValues();
    midUpdates.forEach(update => {
      midValues[update.row - 2][0] = update.value;
    });
    midRange.setValues(midValues);
  }
  
  // Menyimpan waktu sinkronisasi terakhir ke PropertiesService
  const properties = PropertiesService.getScriptProperties();
  const lastSyncTime = Utilities.formatDate(now, timeZone, "dd/MM/yyyy HH:mm:ss");
  properties.setProperty('LAST_SYNC_TIME', lastSyncTime);
  
  return `Sinkronisasi selesai pada sesi ${session}. ${quantityUpdates.length} Lane diperbarui.`;
}

/**
 * Fungsi untuk mengambil waktu sinkronisasi terakhir
 * @returns {string} Waktu sinkronisasi terakhir
 */
function getLastSyncTime() {
  const properties = PropertiesService.getScriptProperties();
  const lastSyncTime = properties.getProperty('LAST_SYNC_TIME');
  return lastSyncTime ? lastSyncTime : "Belum pernah disinkronkan.";
}

/**
 * Fungsi untuk membuat mapping lane dari "SO RAW" ke "LANE STATUS"
 */
function getLaneMapping() {
  return {
    "LANE 1ECERAN": "1E",
    "LANE 2ECERAN": "2E",
    "LANE 3ECERAN": "3E",
    "LANE 4ECERAN": "4E",
    "LANE 5ECERAN": "5E",
    "LANE 6ECERAN": "6E",
    "LANE 7ECERAN": "7E",
    "LANE 8ECERAN": "8E",
    "LANE 9ECERAN": "9E",
    "LANE 10ECERAN": "10E",
    "LANE 11ECERAN": "11E",
    "LANE 12ECERAN": "12E",
    "LANE 13ECERAN": "13E",
    "LANE 14ECERAN": "14E",
    "LANE 15ECERAN": "15E",
    "LANE 1B": "1B",
    "LANE 2B": "2B",
    "LANE 3B": "3B",
    "LANE 4B": "4B",
    "LANE 5B": "5B",
    "LANE 6B": "6B",
    "LANE 7B": "7B",
    "LANE 8B": "8B",
    "LANE 9B": "9B",
    "LANE 10B": "10B",
    "LANE 11B": "11B",
    "LANE 12B": "12B",
    "LANE 13B": "13B",
    "LANE 14B": "14B",
    "LANE 15B": "15B",
    "LANE 16B": "16B",
    "LANE 17B": "17B",
    "LANE 18B": "18B",
    "LANE 19B": "19B",
    "LANE 20B": "20B",
    "LANE 21B": "21B",
    "LANE 22B": "22B",
    "LANE 23B": "23B",
    "LANE 24B": "24B",
    "LANE 25B": "25B",
    "LANE 26B": "26B",
    "LANE 1A": "1A",
    "LANE 2A": "2A",
    "LANE 3A": "3A",
    "LANE 4A": "4A",
    "LANE 5A": "5A",
    "LANE 6A": "6A",
    "LANE 7A": "7A",
    "LANE 8A": "8A",
    "LANE 9A": "9A",
    "LANE 10A": "10A",
    "LANE 11A": "11A",
    "LANE 12A": "12A",
    "LANE 13A": "13A",
    "LANE 14A": "14A",
    "LANE 15A": "15A",
    "LANE 16A": "16A",
    "LANE 17A": "17A",
    "LANE 18A": "18A",
    "LANE 19A": "19A",
    "LANE 20A": "20A",
    "LANE 21A": "21A",
    "LANE 22A": "22A",
    "LANE 23A": "23A",
    "LANE 24A": "24A",
    "LANE 25A": "25A",
    "LANE 26A": "26A"
    // Tambahkan mapping lainnya jika diperlukan
  };
}

/**
 * Fungsi untuk sinkronisasi sesi pagi
 */
function synchronizeMorning() {
  synchronizeData('morning');
}

/**
 * Fungsi untuk sinkronisasi sesi sore
 */
function synchronizeAfternoon() {
  synchronizeData('afternoon');
}
