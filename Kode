function doGet() {
  return HtmlService.createTemplateFromFile('Index').evaluate()
  //return HtmlService.createTemplateFromFile('HistoryOutbound').evaluate()
    .addMetaTag('viewport', 'width=device-width , initial-scale=1')
    //.setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
    .setTitle('WFG');
}

// Function to get the HTML for a specific page
function loadPage(page) {
  return HtmlService.createTemplateFromFile(page).evaluate().getContent();  // Returns the HTML content for the page

}

// Fungsi untuk mengarahkan ke halaman utama (Main Page)
function redirectToMainPage() {
    return HtmlService.createTemplateFromFile('Index').evaluate()
    //return HtmlService.createTemplateFromFile('Builder4').evaluate()
    .addMetaTag('viewport', 'width=device-width , initial-scale=1')
    //.setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
    .setTitle('WFG');
}

function LoadchartapexSankey() {
  // Buka spreadsheet berdasarkan ID
  const ss = SpreadsheetApp.openById('1bH3_loER7TNhomI13gXuuowNA45sIKuO9xbQjw1-WY8');
  const sheet = ss.getSheetByName('LANE STATUS');

  // Ambil data dari sheet
  const data = sheet.getDataRange().getValues();

  // Kembalikan data ke sisi klien
  return data;
}

/* Builder PRD */
/**
 * Fungsi utama untuk memproses data form dan menyimpannya ke Google Sheets.
 * @param {Object} formData - Data yang dikirim dari client-side.
 * @returns {String} - Tabel HTML yang menampilkan data yang telah disubmit.
 */
function processForm(formData) {
  try {
    const sheetId = '1bH3_loER7TNhomI13gXuuowNA45sIKuO9xbQjw1-WY8'; // Ganti dengan ID Sheet Anda
    const sheetName = 'Database';
    const ss = SpreadsheetApp.openById(sheetId);
    let sheet = ss.getSheetByName(sheetName);
    if (!sheet) {
      sheet = ss.insertSheet(sheetName);
    }
    
    // Header utama jika sheet kosong
    if (sheet.getLastRow() === 0) {
      const mainHeaders = ['Timestamp', 'Tanggal', 'Shift', 'Mesin', 'Size', 'Material', 'Stock Awal', 
                          '06:00-07:00', '07:00-08:00', '08:00-09:00', '09:00-10:00', 
                          '10:00-11:00', '11:00-12:00', 'Sisa Produksi Mesin', 'Total Pakai', 'Retur'];
      sheet.appendRow(mainHeaders);
      // Format header utama
      const headerRange = sheet.getRange(1, 1, 1, mainHeaders.length);
      headerRange.setBackground('#343a40').setFontColor('#ffffff').setFontWeight('bold');
    }
    
    // Ekstrak informasi umum dari form
    const TanggalInput = formData.tanggal; // Format input: yyyy-mm-dd
    const Shift = formData.shift;
    const Mesin = formData.mesin;
    const Size = formData.size;

    // Format Tanggal ke dd-MM-yyyy
    const Tanggal = formatDate(TanggalInput, "dd-MM-yyyy");
  
    // Format Timestamp sesuai WIB
    const timestamp = Utilities.formatDate(new Date(), SpreadsheetApp.getActive().getSpreadsheetTimeZone(), "dd-MM-yyyy HH:mm:ss");
    
    // Daftar material
    const materials = [
      "PULP LIGHTHOUSE", "SAP DIAPERS", "BOTTOM TISSUE", "NW INNERWAISTS SSS",
      "NW LEGCUFF SMS", "NWO AT", "NW OUTERWAIST SSS", "PRINTING SACHET",
      "PE FILM", "NW BACKSHEET SSS", "GLUE CORE", "GLUE CONSTRUCTION", 
      "GLUE ELASTIC", "ELASTIC 620DTEX", "NW ADL", "PRINTING BHP (SMALL)",
      "PRINTING BHP (MEDIUM)", "PRINTING BHP (LARGE)", "KARDUS BHP (SMALL)", 
      "KARDUS BHP (MEDIUM)", "KARDUS BHP (LARGE)", "ISOLASI (SACHET)",
      "ISOLASI (BAG)", "ISOLASI (REPACK)"
    ];
  
    // Rentang waktu berdasarkan Shift
    const timeRanges = {
      "1": ["06:00-07:00", "07:00-08:00", "08:00-09:00", "09:00-10:00", "10:00-11:00", "11:00-12:00"],
      "2": ["14:00-15:00", "15:00-16:00", "16:00-17:00", "17:00-18:00", "18:00-19:00", "19:00-20:00"],
      "3": ["22:00-23:00", "23:00-00:00", "00:00-01:00", "01:00-02:00", "02:00-03:00", "03:00-04:00"]
    };
  
    const selectedTimeRanges = timeRanges[Shift] || [];
  
    // Fungsi untuk mendapatkan Shift terakhir di sheet
    function getLastShift() {
      if (sheet.getLastRow() < 2) return null; // Tidak ada data selain header utama
      const lastDataRow = sheet.getLastRow();
      return sheet.getRange(lastDataRow, 3).getValue(); // Shift berada di kolom 3
    }
  
    const lastShift = getLastShift();
  
    // Jika Shift baru, tambahkan header shift
    if (lastShift !== Shift) {
      // Insert header shift
      const shiftHeader = `Shift ${Shift} - Data`;
      sheet.appendRow([shiftHeader]);
      // Merge cells untuk header shift
      const lastRow = sheet.getLastRow();
      sheet.getRange(lastRow, 1, 1, 15).merge().setBackground('#6c757d').setFontColor('#ffffff').setFontWeight('bold').setHorizontalAlignment('center');
      
      // Tambahkan header kolom data setelah header shift
      sheet.appendRow(['Timestamp', 'Tanggal', 'Shift', 'Mesin', 'Size', 'Material', 'Stock Awal', 
                      '06:00-07:00', '07:00-08:00', '08:00-09:00', '09:00-10:00', 
                      '10:00-11:00', '11:00-12:00', 'Sisa Produksi Mesin', 'Total Pakai', 'Retur']);
      const dataHeaderRange = sheet.getRange(sheet.getLastRow(), 1, 1, 15);
      dataHeaderRange.setBackground('#343a40').setFontColor('#ffffff').setFontWeight('bold');
    }
  
    // Loop melalui setiap material untuk menyimpan data
    materials.forEach(function(material) {
      const stockAwal = parseFloat(formData["stockAwal_" + material]) || 0;
      const sisa = parseFloat(formData["sisa_" + material]) || 0;
      const total = parseFloat(formData["total_" + material]) || 0;
      const retur = parseFloat(formData["retur_" + material]) || 0;
  
      // Mengumpulkan data per jam untuk setiap material
      const hours = selectedTimeRanges.map(function(time) {
        return parseFloat(formData[`${material}_${time}`]) || 0;
      });
  
      // Menyiapkan data baris untuk sheet
      const rowData = [timestamp, Tanggal, Shift, Mesin, Size, material, stockAwal].concat(hours, [sisa, total, retur]);
  
      // Append row
      sheet.appendRow(rowData);
      const appendedRow = sheet.getLastRow();
      const range = sheet.getRange(appendedRow, 1, 1, rowData.length);
      
      // Atur border untuk baris yang baru ditambahkan
      range.setBorder(true, true, true, true, true, true, "black", SpreadsheetApp.BorderStyle.SOLID);
    });
  
    // Tambahkan baris kosong untuk spasi antar pengiriman data
    sheet.appendRow(['','','','','','','','','','','','','','','']);
  
    // Membuat HTML tabel dari data yang dikirim untuk ditampilkan sebagai konfirmasi
    let htmlTable = `
      <h3 class="text-center">Hasil Pengiriman Laporan Pemakaian Material</h3>
      <div style="overflow-x:auto;">
        <table class="table table-bordered">
          <thead class="table-dark">
            <tr>
              <th>Material</th>
              <th>Stock Awal</th>
              ${selectedTimeRanges.map(time => `<th>${time}</th>`).join('')}
              <th>Sisa Produksi Mesin</th>
              <th>Total Pakai</th>
              <th>Retur</th>
            </tr>
          </thead>
          <tbody>
    `;
  
    materials.forEach(function(material) {
      const stockAwal = parseFloat(formData["stockAwal_" + material]) || 0;
      const sisa = parseFloat(formData["sisa_" + material]) || 0;
      const total = parseFloat(formData["total_" + material]) || 0;
      const retur = parseFloat(formData["retur_" + material]) || 0;
  
      const row = `
        <tr>
          <td>${material}</td>
          <td>${stockAwal}</td>
          ${selectedTimeRanges.map(time => `<td>${parseFloat(formData[`${material}_${time}`]) || 0}</td>`).join('')}
          <td>${sisa}</td>
          <td>${total}</td>
          <td>${retur}</td>
        </tr>
      `;
      htmlTable += row;
    });
  
    htmlTable += `
          </tbody>
        </table>
      </div>
    `;
  
    return htmlTable;
  } catch (error) {
    Logger.log(error);
    return `<p>Error: ${error.toString()}</p>`;
  }
}

/**
 * Fungsi untuk mengambil semua data dari sheet dan mengembalikannya sebagai tabel HTML.
 * @returns {String} - Tabel HTML yang menampilkan semua data.
 */
function getAllData() {
  try {
    const sheetId = '1bH3_loER7TNhomI13gXuuowNA45sIKuO9xbQjw1-WY8';
    const sheetName = 'Database';
    const ss = SpreadsheetApp.openById(sheetId);
    const sheet = ss.getSheetByName(sheetName);
    
    if (!sheet) return '<p>Tidak ada data yang tersedia.</p>';
    
    const data = sheet.getDataRange().getValues();
    if (data.length === 0) return '<p>Tidak ada data yang tersedia.</p>';
    
    // Mendapatkan indeks kolom yang akan ditampilkan (hapus 'Timestamp')
    const headers = data[0];
    const displayHeaders = headers.filter((header, index) => index !== 0); // Menghapus kolom 0 (Timestamp)
    
    let htmlTable = `
      <h3 class="text-center">Semua Data Laporan Pemakaian Material</h3>
      <div style="overflow-x:auto;">
        <table class="table table-bordered">
          <thead class="table-dark">
            <tr>
              ${displayHeaders.map(header => `<th>${header}</th>`).join('')}
            </tr>
          </thead>
          <tbody>
    `;
    
    // Mulai dari baris ke-2
    for (let i = 1; i < data.length; i++) {
      // Skip header shift rows
      if (data[i][0].toString().startsWith('Shift')) continue;
      
      // Filter data: hanya menampilkan kolom selain Timestamp
      const rowData = data[i].filter((cell, index) => index !== 0);
      
      // Format 'Tanggal' jika diperlukan (pastikan kolom 'Tanggal' berada di indeks yang benar)
      // Misalnya, jika 'Tanggal' adalah kolom ke-2 (index 1 sebelum filter)
      const tanggalIndex = 1; // Sesuaikan jika posisi 'Tanggal' berbeda
      if (rowData[tanggalIndex - 1]) { // Setelah filter, 'Tanggal' menjadi indeks 0
        rowData[tanggalIndex - 1] = formatDate(rowData[tanggalIndex - 1], "dd-MM-yyyy");
      }
      
      htmlTable += `<tr>${rowData.map(cell => `<td>${cell}</td>`).join('')}</tr>`;
    }
    
    htmlTable += `
          </tbody>
        </table>
      </div>
    `;
    
    return htmlTable;
    
  } catch (error) {
    Logger.log(error);
    return `<p>Error: ${error.toString()}</p>`;
  }
}

/**
 * Fungsi untuk mengambil data berdasarkan filter Shift, Mesin, dan Size.
 * @param {String} shift - Shift yang dipilih (1, 2, 3) atau kosong untuk semua shift.
 * @param {String} mesin - Mesin yang dipilih (1, 2, 3) atau kosong untuk semua mesin.
 * @param {String} size - Size yang dipilih (S, M, L, XL, XXL) atau kosong untuk semua size.
 * @returns {String} - Tabel HTML yang menampilkan data sesuai filter.
 */
function getFilteredData(shift, mesin, size) {
  try {
    const sheetId = '1bH3_loER7TNhomI13gXuuowNA45sIKuO9xbQjw1-WY8';
    const sheetName = 'Database';
    const ss = SpreadsheetApp.openById(sheetId);
    const sheet = ss.getSheetByName(sheetName);
    
    if (!sheet) return '<p>Tidak ada data yang tersedia.</p>';
    
    const data = sheet.getDataRange().getValues();
    if (data.length === 0) return '<p>Tidak ada data yang tersedia.</p>';
    
    // Mendapatkan indeks kolom yang akan ditampilkan (hapus 'Timestamp')
    const headers = data[0];
    const displayHeaders = headers.filter((header, index) => index !== 0); // Menghapus kolom 0 (Timestamp)
    
    let htmlTable = `
      <h3 class="text-center">Data Laporan Pemakaian Material</h3>
      <div style="overflow-x:auto;">
        <table class="table table-bordered">
          <thead class="table-dark">
            <tr>
              ${displayHeaders.map(header => `<th>${header}</th>`).join('')}
            </tr>
          </thead>
          <tbody>
    `;
    
    // Mulai dari baris ke-2
    for (let i = 1; i < data.length; i++) {
      // Skip header shift rows
      if (data[i][0].toString().startsWith('Shift')) continue;
      
      // Filter berdasarkan Shift, Mesin, dan Size
      const rowShift = data[i][2].toString();
      const rowMesin = data[i][3].toString();
      const rowSize = data[i][4].toString();
  
      const matchShift = shift ? (rowShift === shift) : true;
      const matchMesin = mesin ? (rowMesin === mesin) : true;
      const matchSize = size ? (rowSize === size) : true;
  
      if (matchShift && matchMesin && matchSize) {
        // Filter data: hanya menampilkan kolom selain Timestamp
        const rowData = data[i].filter((cell, index) => index !== 0);
        
        // Format 'Tanggal' jika diperlukan (pastikan kolom 'Tanggal' berada di indeks yang benar)
        // Misalnya, jika 'Tanggal' adalah kolom ke-2 (index 1 sebelum filter)
        const tanggalIndex = 1; // Sesuaikan jika posisi 'Tanggal' berbeda
        if (rowData[tanggalIndex - 1]) { // Setelah filter, 'Tanggal' menjadi indeks 0
          rowData[tanggalIndex - 1] = formatDate(rowData[tanggalIndex - 1], "dd-MM-yyyy");
        }
        
        htmlTable += `<tr>${rowData.map(cell => `<td>${cell}</td>`).join('')}</tr>`;
      }
    }
    
    htmlTable += `
          </tbody>
        </table>
      </div>
    `;
    
    if (!htmlTable.includes('<tr>')) {
      htmlTable = '<p>Tidak ada data yang sesuai dengan filter yang dipilih.</p>';
    }

    return htmlTable;

  } catch (error) {
    Logger.log(error);
    return `<p>Error: ${error.toString()}</p>`;
  }
}

/**
 * Fungsi untuk memformat tanggal sesuai dengan format yang diinginkan.
 * @param {String|Date} dateInput - Tanggal dalam format string atau objek Date.
 * @param {String} format - Format yang diinginkan, misalnya "dd-MM-yyyy".
 * @returns {String} - Tanggal yang diformat.
 */
function formatDate(dateInput, format) {
  if (!dateInput) return '';
  
  let dateObj;
  
  if (typeof dateInput === 'string') {
    // Parsing tanggal dari string
    dateObj = new Date(dateInput);
  } else if (dateInput instanceof Date) {
    dateObj = dateInput;
  } else {
    return '';
  }
  
  return Utilities.formatDate(dateObj, SpreadsheetApp.getActive().getSpreadsheetTimeZone(), format);
}



/**
 * INCLUDE HTML PARTS, EG. JAVASCRIPT, CSS, OTHER HTML FILES
 */
function include(filename) {
  return HtmlService.createHtmlOutputFromFile(filename).getContent();
}

function submitDataSO(data) {
  const sheetId = '1bH3_loER7TNhomI13gXuuowNA45sIKuO9xbQjw1-WY8';
  const sheetName = 'SO RAW';
  const sheet = SpreadsheetApp.openById(sheetId).getSheetByName(sheetName);
  
  // Menyisipkan data ke sheet
  sheet.getRange(sheet.getLastRow() + 1, 1, data.length, data[0].length).setValues(data);
}

function getDataByDateZoneAndSession(date, zoneFilter, sessionFilter) {
  const sheet = SpreadsheetApp.openById('1bH3_loER7TNhomI13gXuuowNA45sIKuO9xbQjw1-WY8').getSheetByName('SO RAW');
  const data = sheet.getDataRange().getValues(); // Ambil semua data dari sheet
  
  const inputDate = new Date(date); // Konversi input tanggal dari pengguna
  
  // Filter data berdasarkan tanggal, zona, dan session
  const filteredData = data.filter(row => {
    let rowDateText = row[5];  // Asumsikan kolom F (indeks 5) berisi tanggal dan waktu
    let rowDate = new Date(rowDateText);
    const rowTime = rowDate.getHours(); // Ambil jam dari timestamp

    // Handle format tanggal yang tidak valid
    if (isNaN(rowDate)) {
      const parts = rowDateText.split('/');
      if (parts.length === 3) {
        const day = parseInt(parts[0], 10);
        const month = parseInt(parts[1], 10) - 1;
        const year = parseInt(parts[2], 10);
        rowDate = new Date(year, month, day);
      }
    }

    // Filter berdasarkan tanggal
    const isDateMatch = rowDate.toDateString() === inputDate.toDateString();

    // Filter berdasarkan zona
    const isZoneMatch = zoneFilter === '' || row[4].startsWith(zoneFilter); // Asumsikan kolom E (indeks 4) berisi zona

    // Filter berdasarkan session (morning atau afternoon)
    let isSessionMatch = false;
    if (sessionFilter === 'morning') {
      isSessionMatch = rowTime >= 1 && rowTime < 13; // Morning: 01:00 AM - 12:00 PM
    } else if (sessionFilter === 'afternoon') {
      isSessionMatch = rowTime >= 13 && rowTime < 24; // Afternoon: 01:00 PM - 12:00 AM
    }

    return isDateMatch && isZoneMatch && isSessionMatch;
  });

  // Ambil data dari kolom A-F (indeks 0-5) tanpa memotong kode zona
  const modifiedData = filteredData.map(row => row.slice(0, 6));
  
  return modifiedData; // Kembalikan data yang sudah difilter
}

function updateQuantityInSpreadsheetByUniqueCode(uniqueCode, newQuantity) {
  const sheet = SpreadsheetApp.openById('1bH3_loER7TNhomI13gXuuowNA45sIKuO9xbQjw1-WY8').getSheetByName('SO RAW');
  const data = sheet.getDataRange().getValues();
  
  // Cari row berdasarkan seluruh isi unique code (kolom ZONE)
  const rowIndex = data.findIndex(row => row[4] === uniqueCode);
  
  if (rowIndex !== -1) {
    // Jika ditemukan, perbarui kolom QTY (kolom D)
    sheet.getRange(rowIndex + 1, 4).setValue(newQuantity); // Update kolom QTY
  } else {
    throw new Error('Unique code not found.');
  }
}

function getDataSO() {
  const sheet = SpreadsheetApp.openById('1bH3_loER7TNhomI13gXuuowNA45sIKuO9xbQjw1-WY8').getSheetByName('SO RAW');
  const data = sheet.getDataRange().getValues(); // Fetch all data from the sheet
  
  const currentDate = new Date();
  const currentDateString = currentDate.toDateString();
  const currentHour = currentDate.getHours();

  // Determine the session based on the current time
  let session;
  if (currentHour >= 1 && currentHour < 13) {
    session = 'morning'; // Session 1: 01:00 AM - 12:00 PM
  } else if (currentHour >= 13 && currentHour < 24) {
    session = 'afternoon'; // Session 2: 01:00 PM - 12:00 AM
  } else {
    return {}; // If outside of work hours, return an empty object
  }
  
  const result = {};

  data.forEach(row => {
    const rowDate = new Date(row[5]).toDateString(); // Column F contains the date
    const rowTime = new Date(row[5]).getHours(); // Extract the hour from the timestamp
    const mid = row[1]; // Column B for MID
    const productName = row[2]; // Column C for Product Name
    let quantity = row[3]; // Column D for Quantity
    const zone = row[4]; // Column E for Zone
    const conv = getConv(productName); // Fetch the conversion rate

    // Filter data by current date and session
    if (rowDate === currentDateString) {
      if ((session === 'morning' && rowTime >= 1 && rowTime < 13) || 
          (session === 'afternoon' && rowTime >= 13 && rowTime < 24)) {
        
        // Apply the conversion based on the zone
        if (zone.startsWith("ZONAA") || zone.startsWith("ZONAB") || zone.startsWith("ZONAR")) {
          quantity *= conv;
        } else if (zone.startsWith("ZONAE")) {
          quantity *= 1;
        }

        // Aggregate the quantity per product name
        if (result[productName]) {
          result[productName] += quantity;
        } else {
          result[productName] = quantity;
        }
      }
    }
  });

  return result; // Return the aggregated resultsubmit
}

function getConv(productName) {
  const conversionTable = {
    'L1': 64,
    'M1': 64,
    'XL1': 49,
    'L28': 32,
    'M32': 32,
    'XL26': 32,
    'L8': 45,
    'XL7': 9,
    'L11': 56,
    'M11': 56,
    'XL11': 42
  };
  
  return conversionTable[productName] || 1; // Default conversion rate is 1 if not found
}

function submitDataWithRemarksAndSession(data, remarks, dateWithTime, session) {
  const sheet = SpreadsheetApp.openById('1bH3_loER7TNhomI13gXuuowNA45sIKuO9xbQjw1-WY8').getSheetByName("SO FINAL");
  const existingData = sheet.getRange('A:B').getValues(); // Fetch date and session columns

  // Extract the date from dateWithTime (format: DD/MM/YYYY HH:MM:SS)
  const submittedDate = dateWithTime.split(' ')[0]; // Get only the date part

  // Check if data for the same date and session already exists
  const isDuplicate = existingData.some(row => {
    const existingDate = row[0].toString().split(' ')[1]; // Get date from the sheet
    const existingSession = row[1]; // Get session (morning/afternoon) from the sheet
    return existingDate === submittedDate && existingSession === session;
  });

  // If a duplicate is found, return this information
  if (isDuplicate) {
    return { isDuplicate: true, session: session };
  }

  // If no duplicate, append the new data
  let lastRow = sheet.getLastRow(); // Find the last row in the sheet
  
  lastRow += 3; // Add 3 blank rows before appending new data

  // Insert a new row with the date and session
  sheet.getRange(lastRow + 1, 1).setValue(`Date: ${dateWithTime}`);
  sheet.getRange(lastRow + 1, 2).setValue(session); // Insert the session (morning/afternoon)

  // Add column headers
  sheet.getRange(lastRow + 2, 1, 1, 6).setValues([["MID", "NAME", "CONV", "QTY SO", "QTY SAP", "DIFF SO-SAP"]]);

  // Insert the data into the sheet
  const dataRange = sheet.getRange(lastRow + 3, 1, data.length, 6);
  const dataValues = data.map(item => [item.MID, item.Name, item.CONV, item.qtySO, item.qtySAP, item.diffSO_SAP]);
  dataRange.setValues(dataValues);

  // Add a row for remarks after the data
  const remarksRowIndex = lastRow + data.length + 4; 
  sheet.getRange(remarksRowIndex, 1, 1, 6).merge();  // Merge the first 6 columns
  sheet.getRange(remarksRowIndex, 1).setValue(`Remarks: ${remarks}`);

  // Apply borders around the newly added data
  const totalRows = data.length + 3; // Include the date, session, and header rows
  const borderRange = sheet.getRange(lastRow + 1, 1, totalRows, 6);
  borderRange.setBorder(true, true, true, true, true, true);

  return { isDuplicate: false, session: session }; // Return success
}

function getDiffSoSapByDate(selectedDate) {
  const sheet = SpreadsheetApp.openById('1bH3_loER7TNhomI13gXuuowNA45sIKuO9xbQjw1-WY8').getSheetByName('SO FINAL');
  const data = sheet.getDataRange().getValues(); // Get all data from the sheet

  const result = {};
  const targetDateString = `Date: ${selectedDate}`;  // Format the selected date string

  // Loop through the data to find the row with the selected date
  for (let i = 0; i < data.length; i++) {
    if (data[i][0] && data[i][0].toString().startsWith(targetDateString)) {
      // Find the header row (two rows after the date header)
      const headerRow = i + 1;
      for (let j = headerRow + 1; j < data.length; j++) {
        // Stop at the next date header or blank row
        if (!data[j][0] || data[j][0].toString().startsWith('Date:')) break;

        // Collect DIFF SO-SAP values (assuming 6th column is DIFF SO-SAP)
        const productName = data[j][1];  // Assuming second column is the product name
        const diffSoSap = data[j][5];    // Assuming sixth column is DIFF SO-SAP
        result[productName] = diffSoSap;
      }
      break; // Exit loop once the date has been found and data collected
    }
  }

  return result;  // Return the DIFF SO-SAP data for the selected date
}

function getDataSOWithRemarksByDate(selectedDate, session) {
  const sheet = SpreadsheetApp.openById('1bH3_loER7TNhomI13gXuuowNA45sIKuO9xbQjw1-WY8').getSheetByName('SO FINAL');
  const dataRange = sheet.getRange(1, 1, sheet.getLastRow(), 6).getValues(); // Mengambil semua data

  const filteredData = [];
  let remarks = '';
  const targetDateString = `Date: ${selectedDate}`;  // Membentuk string untuk memeriksa tanggal
  
  // Looping untuk mencari baris yang cocok dengan tanggal dan sesi
  for (let i = 0; i < dataRange.length; i++) {
    const dateCell = dataRange[i][0] ? dataRange[i][0].toString() : '';  // Ambil nilai dari kolom pertama (Tanggal dan waktu)
    const sessionCell = dataRange[i][1] ? dataRange[i][1].toString().toLowerCase() : '';  // Ambil nilai dari kolom kedua (Sesi)

    // Memeriksa apakah tanggal dan sesi cocok
    if (dateCell.includes(targetDateString) && sessionCell.includes(session)) {
      // Ambil data setelah menemukan tanggal dan sesi yang cocok
      for (let j = i + 2; j < dataRange.length && dataRange[j][0] !== ''; j++) {
        filteredData.push(dataRange[j]);  // Simpan baris data yang relevan
      }

      // Ambil remarks dari dua baris setelah data selesai
      const remarksRowIndex = i + filteredData.length + 3;
      remarks = dataRange[remarksRowIndex] && dataRange[remarksRowIndex][0]
        ? dataRange[remarksRowIndex][0].replace('Remarks: ', '')
        : '';
      break;
    }
  }

  return {
    data: filteredData,
    remarks: remarks
  };
}

function getDiffPreviousByDate(selectedDate) {
  const sheet = SpreadsheetApp.openById('1bH3_loER7TNhomI13gXuuowNA45sIKuO9xbQjw1-WY8').getSheetByName('SO FINAL');
  const dataRange = sheet.getRange(1, 1, sheet.getLastRow(), 6).getValues(); // Mengambil semua data dari A hingga F (kolom ke-6)
  
  const diffPreviousData = [];

  // Looping melalui semua baris di dataRange untuk mencari tanggal yang sesuai
  for (let i = 0; i < dataRange.length; i++) {
    // Memeriksa apakah ada baris dengan tanggal yang cocok dengan tanggal dari FILTER DIFF PREVIOUS
    if (dataRange[i][0].toString().includes(`Date: ${selectedDate}`)) {
      // Mengambil nilai "DIFF PREVIOUS" dari kolom F (kolom ke-6, indeks 5) setelah menemukan tanggal yang cocok
      for (let j = i + 2; j < dataRange.length && dataRange[j][0] !== ''; j++) {
        diffPreviousData.push(dataRange[j][5]); // Kolom F berada pada indeks ke-5
      }
      break;
    }
  }

  return {
    data: diffPreviousData
  };
}

function getChartData() {
  const sheet = SpreadsheetApp.openById('1ynFYdKg2XdAdTQWw_U52wf_dvPiJWHUCd09mcu37d8k').getSheetByName('Taker');
  const data = sheet.getDataRange().getValues();
  
  // Remove the header
  data.shift();

  // MID values to track
  const mids = ['L1', 'M1', 'XL1', 'L28', 'M32', 'XL26', 'L8', 'XL7', 'L11', 'M11', 'XL11'];
  const colors = ['rgba(255, 99, 132, 1)', 'rgba(54, 162, 235, 1)', 'rgba(255, 206, 86, 1)',
                  'rgba(75, 192, 192, 1)', 'rgba(153, 102, 255, 1)', 'rgba(255, 159, 64, 1)',
                  'rgba(199, 199, 199, 1)', 'rgba(83, 102, 255, 1)', 'rgba(23, 206, 86, 1)',
                  'rgba(200, 192, 132, 1)', 'rgba(199, 100, 64, 1)'];
  
  // Helper function to format date as 'dd-MM-yyyy'
  const formatDate = date => {
    if (date instanceof Date && !isNaN(date)) {
      return Utilities.formatDate(date, Session.getScriptTimeZone(), 'dd-MM-yyyy');
    }
    return null; // Ignore invalid dates
  };

  // Prepare an object to aggregate data by MID and date
  const dateData = mids.reduce((acc, mid) => {
    acc[mid] = {}; // Initialize empty object for each MID
    return acc;
  }, {});

  // Aggregate the quantities by MID and exact date
  data.forEach(row => {
    const mid = row[2]; // MID is in column C
    const quantity = row[3]; // Quantity is in column D
    const rawDate = new Date(row[5]); // Column F contains the date
    const formattedDate = formatDate(rawDate);

    if (formattedDate) {
      if (!dateData[mid][formattedDate]) {
        dateData[mid][formattedDate] = 0; // Initialize if not present
      }
      dateData[mid][formattedDate] += quantity; // Sum the quantities for each date
    }
  });

  // Extract all unique dates, sorted in chronological order
  const uniqueDates = [...new Set(data.map(row => formatDate(new Date(row[5]))).filter(date => date))]
                       .sort((a, b) => new Date(a.split('-').reverse().join('-')) - new Date(b.split('-').reverse().join('-')));

  // Create a dataset object for each MID
  const datasets = mids.map((mid, index) => {
    const quantities = uniqueDates.map(date => dateData[mid][date] || 0); // Use 0 if no data for that date

    return {
      label: mid,
      data: quantities,
      type: 'line',
      borderColor: colors[index],
      backgroundColor: colors[index].replace('1)', '0.2)'), // Adjust transparency
      borderWidth: 2
    };
  });

  // Combine all datasets into one data object
  return {
    labels: uniqueDates, // Use the formatted dates as labels
    datasets: datasets
  };
}

function getSheetData() {
  const sheet = SpreadsheetApp.openById('1ynFYdKg2XdAdTQWw_U52wf_dvPiJWHUCd09mcu37d8k').getSheetByName('Taker');
  
  // Get data starting from the third row (skipping the first two header rows)
  const dataRange = sheet.getRange(3, 1, sheet.getLastRow() - 2, sheet.getLastColumn());
  const data = dataRange.getValues(); // Fetch all data starting from the third row

  // Transform data into an array of objects
  const transformedData = data.map(row => {
    let waktu = '';

    // Check if row[5] contains a valid Date
    if (row[5] instanceof Date) {
      // Format the date and time for 'waktu'
      const dayFormatted = Utilities.formatDate(row[5], Session.getScriptTimeZone(), "dd-MM-yyyy"); // Format date
      const timeFormatted = Utilities.formatDate(row[5], Session.getScriptTimeZone(), "HH:mm:ss"); // Format time
      waktu = `${dayFormatted} ${timeFormatted}`; // Combine date and time into one string
    } else {
      waktu = 'Invalid time'; // Fallback in case 'row[5]' is not a valid Date
    }

    return {
      checker: row[0] || '',  // Assuming 'Checker' is in the first column
      gate: row[1] || '',     // Assuming 'Gate' is in the second column
      product: row[2] || '',  // Assuming 'Product' is in the third column
      quantity: row[3] || 0,  // Assuming 'Quantity' is in the fourth column (default to 0 if empty)
      waktu: waktu            // Formatted 'waktu' value (either a valid date/time or 'Invalid time')
    };
  });

  return transformedData;
}

function getDataByDateAndSession(selectedDate, session) {
  const sheet = SpreadsheetApp.openById('1bH3_loER7TNhomI13gXuuowNA45sIKuO9xbQjw1-WY8').getSheetByName('SO RAW');
  const data = sheet.getDataRange().getValues();
  
  const inputDate = new Date(selectedDate);

  // Filter data based on the selected date and session
  const filteredData = data.filter(row => {
    const rowDate = new Date(row[5]);
    const isDateMatch = rowDate.toDateString() === inputDate.toDateString();

    const currentHour = new Date(row[5]).getHours();
    const isSessionMatch = (session === 'morning' && currentHour >= 1 && currentHour < 13) || 
                           (session === 'afternoon' && currentHour >= 13 && currentHour < 24);

    return isDateMatch && isSessionMatch;
  });

  const modifiedData = filteredData.map(row => {
    return {
      lane: row[0],             // Lane (e.g., 'LANE 1A')
      productName: row[2] || 'N/A', // Product name
      quantity: row[3],          // Quantity
      date: row[5]               // Date information
    };
  });

  return modifiedData;  // Return the filtered data
}

// Fungsi untuk memproses login
function processLogin(username, password) {
  // Daftar pengguna dan kata sandi
  var users = {
    "checker": "123",
    "admin": "123",
    "staff": "123"
  };
  
  // Cek apakah username dan password cocok
  if (users[username] && users[username] === password) {
    return 'success';
  } else {
    return 'failure';
  }
}


function getZoneData() {
  const sheet = SpreadsheetApp.openById('1bH3_loER7TNhomI13gXuuowNA45sIKuO9xbQjw1-WY8').getSheetByName('SO RAW');
  const data = sheet.getDataRange().getValues();
  
  const zones = [];
  const currentTime = new Date(); // Get current date and time
  const currentDate = currentTime.toDateString(); // Get current date string
  const currentHour = currentTime.getHours(); // Get the current hour
  
  // Determine the session based on the current time
  let session;
  if (currentHour >= 1 && currentHour < 13) {
    session = 'morning'; // Session 1: 01:00 AM - 12:00 PM
  } else if (currentHour >= 13 && currentHour < 24) {
    session = 'afternoon'; // Session 2: 01:00 PM - 12:00 AM
  } else {
    session = 'out-of-hours'; // If outside of work hours
  }
  
  let hasValidData = false;  // Flag to track if we find matching data for the session

  // Iterate through the data and check for row[4] and row[5] conditions
  for (let i = 0; i < data.length; i++) {
    const rowValue = data[i][4].toString().substring(0, 5);  // Get first 5 characters of row[4]
    const rowDateTime = new Date(data[i][5]);  // Convert row[5] to a date object
    const rowDate = rowDateTime.toDateString();  // Get date part of row[5]
    const rowHour = rowDateTime.getHours();  // Get hour part of row[5]

    // Check if row[5] date matches current date and falls within the session
    if (rowDate === currentDate) {
      if (session === 'morning' && rowHour >= 1 && rowHour < 13) {
        hasValidData = true;
        if (rowValue === 'ZONAA' || rowValue === 'ZONAB' || rowValue === 'ZONAE') {
          zones.push(rowValue);
        }
      } else if (session === 'afternoon' && rowHour >= 13 && rowHour < 24) {
        hasValidData = true;
        if (rowValue === 'ZONAA' || rowValue === 'ZONAB' || rowValue === 'ZONAE') {
          zones.push(rowValue);
        }
      }
    }
  }

  // If no valid rows are found for the session, return an empty zones array
  return { zones, session, hasValidData };  // Include hasValidData in the response
}

/* Function INBOUND RAW */
// Fungsi untuk menghasilkan Unique ID
function generateUniqueId(zone) {
  const pattern = zone === 'A' ? 'ZONAA-xxxx-4xxx-yxxx-xxxxxxxxxxxx' : 'ZONAB-xxxx-4xxx-yxxx-xxxxxxxxxxxx';
  return pattern.replace(/[xy]/g, function(c) {
    const r = Math.random() * 16 | 0;
    const v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}

//BUILDER5
/**
 * Mendapatkan status terkini dari setiap lane berdasarkan zona.
 * @param {string} zone - Zona yang dipilih ('A' atau 'B').
 * @returns {Object} - Objek dengan key adalah Lane ID dan value adalah jumlah pallet, MID, dan setting saat ini.
 */
function getLaneStatus(zone) {
  const ss = SpreadsheetApp.openById('1bH3_loER7TNhomI13gXuuowNA45sIKuO9xbQjw1-WY8'); // Ganti dengan ID Spreadsheet Anda
  const sheet = ss.getSheetByName('LANE STATUS'); // Ganti dengan nama sheet yang sesuai
  const data = sheet.getDataRange().getValues(); // Asumsi baris pertama adalah header

  const laneStatus = {};
  for (let i = 1; i < data.length; i++) {
    const row = data[i];
    const laneId = row[0];    // Kolom A: Lane ID
    const laneZone = row[1];  // Kolom B: Zona
    const currentPallet = row[2]; // Kolom C: Jumlah Pallet
    const currentMID = row[3]; // Kolom D: MID (Kolom tambahan yang menyimpan MID)
    const currentSetting = row[4]; // Kolom E: Setting (Kolom tambahan untuk setting)

    if (laneZone === zone) {
      laneStatus[laneId] = {
        currentPallet,
        currentMID,
        currentSetting
      };
    }
  }
  return laneStatus;
}

/**
 * Memproses data yang disubmit dari frontend.
 * @param {Object} data - Data yang dikirim dari frontend.
 * @returns {Object} - Respons dari backend.
 */
function submitDataInboundRawFullPallet(data) {
  const ss = SpreadsheetApp.openById('1bH3_loER7TNhomI13gXuuowNA45sIKuO9xbQjw1-WY8'); // Ganti dengan ID Spreadsheet Anda
  const laneSheet = ss.getSheetByName('LANE STATUS'); // Sheet untuk status lane
  const logSheet = ss.getSheetByName('INBOUND RAW'); // Sheet untuk mencatat log
  const dataSheet = ss.getSheetByName('Data'); // Sheet untuk data form (opsional)

  // Destructuring data from the submission
  const { zone, mid, lane, setting, stopwatchTime } = data;

  // Validate the incoming data
  if (!zone || !mid || !lane || !setting) {
    return { success: false, message: 'Data tidak lengkap.' };
  }

  // Fetch the data from the LANE STATUS sheet
  const laneData = laneSheet.getDataRange().getValues();
  let targetRow = -1;
  let currentMID = ""; // To store the existing MID in the lane, if any

  // Search for the row that corresponds to the selected lane and zone
  for (let i = 1; i < laneData.length; i++) { // Start from 1 to skip the header row
    const row = laneData[i];
    const laneId = row[0];  // Lane ID (Column A)
    const laneZone = row[1];  // Zone (Column B)
    currentMID = row[3];  // MID (Column D)
    
    if (laneId === lane && laneZone === zone) {
      targetRow = i + 1;  // Store the target row index (+1 for getRange compatibility)
      break;
    }
  }

  // If the lane is not found in the LANE STATUS sheet, return an error
  if (targetRow === -1) {
    return { success: false, message: `Lane ${lane} tidak ditemukan di Zona ${zone}.` };
  }

  // Check if there is already a different MID assigned to the lane
  if (currentMID && currentMID !== mid) {
    return { success: false, message: `Lane ${lane} sudah memiliki MID ${currentMID}. Tidak bisa menambahkan MID yang berbeda (${mid}).` };
  }

  // Fetch the current pallet count and maximum pallet count
  const currentPallet = laneSheet.getRange(targetRow, 3).getValue();  // Column C: Current Pallet Count
  const maxPallet = getMaxPallet(lane);  // Get the max pallet count for the lane

  // Calculate the new pallet count after the addition
  const newPalletCount = currentPallet + parseInt(setting);

  // Check if the new pallet count exceeds the lane's capacity
  if (newPalletCount > maxPallet) {
    return { success: false, message: `Penambahan ${setting} pallet melebihi kapasitas Lane ${lane} (${currentPallet}/${maxPallet}).` };
  }

  // Update the pallet count, MID, and setting in the LANE STATUS sheet
  laneSheet.getRange(targetRow, 3).setValue(newPalletCount);  // Update the pallet count (Column C)
  laneSheet.getRange(targetRow, 4).setValue(mid);  // Update the MID (Column D)
  laneSheet.getRange(targetRow, 5).setValue(setting);  // Update the setting (Column E)

  // Tambahkan tanggal submit di Kolom F
  const submissionDate = Utilities.formatDate(new Date(), "GMT+7", "yyyy-MM-dd");
  laneSheet.getRange(targetRow, 6).setValue(submissionDate); // Kolom F: Tanggal Submit


  // Generate a unique ID for this submission
  const uniqueId = generateUniqueId(zone);

  // Log the submission in the INBOUND RAW sheet
  const date = Utilities.formatDate(new Date(), "GMT+7", "yyyy-MM-dd");
  const time = Utilities.formatDate(new Date(), "GMT+7", "HH:mm:ss");
  logSheet.appendRow([uniqueId, date, time, zone, mid, lane, setting, stopwatchTime]);

  // Optionally, add the data to another sheet for form data (if applicable)
  if (dataSheet) {
    dataSheet.appendRow([uniqueId, date, time, zone, mid, lane, setting, stopwatchTime]);
  }

  // Return a success response
  return { success: true, uniqueId, date, time };
}

/**
 * Fungsi untuk menghasilkan Unique ID
 * @param {string} zone - Zona ('A' atau 'B')
 * @returns {string} - Unique ID sesuai format
 */
function generateUniqueId(zone) {
  const pattern = zone === 'A' ? 'ZONAA-xxxx-4xxx-yxxx-xxxxxxxxxxxx' : 'ZONAB-xxxx-4xxx-yxxx-xxxxxxxxxxxx';
  return pattern.replace(/[xy]/g, function(c) {
    const r = Math.random() * 16 | 0;
    const v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}

/**
 * Menentukan kapasitas maksimal berdasarkan Lane ID.
 * @param {string} laneId - Lane ID (misalnya, '11A', '10B').
 * @returns {number} - Kapasitas maksimal pallet untuk lane tersebut.
 */
function getMaxPallet(laneId) {
  const specialLanesA = ['11A', '17A', '23A'];
  const specialLanesB = ['10B', '22B'];
  if (specialLanesA.includes(laneId) || specialLanesB.includes(laneId)) {
    return 30;
  }
  return 75;
}

function unlockForm() {
  // Buka kunci semua input form yang terkunci
  const formElements = document.querySelectorAll('#palletForm select, #palletForm input');
  formElements.forEach(element => {
    element.disabled = false; // Aktifkan kembali semua input yang sebelumnya terkunci
  });

  // Sembunyikan tombol unlock setelah diklik
  document.getElementById('unlockButton').style.display = 'none';
  
  // Kembalikan focus pada form
  document.getElementById('palletForm').focus();
}

/**
 * Retrieves lane status data from the specified Google Sheets spreadsheet.
 *
 * @return {Array} An array of lane status objects.
 */
function getLaneStatusData() {
  const spreadsheetId = '1bH3_loER7TNhomI13gXuuowNA45sIKuO9xbQjw1-WY8';
  const sheetName = 'LANE STATUS';
  
  // Open the spreadsheet and select the sheet
  const ss = SpreadsheetApp.openById(spreadsheetId);
  const sheet = ss.getSheetByName(sheetName);
  
  if (!sheet) {
    throw new Error(`Sheet "${sheetName}" not found in spreadsheet.`);
  }
  
  // Get all data from the sheet
  const data = sheet.getDataRange().getValues();
  
  // Extract headers
  const headers = data[0];
  
  // Define the MID values to filter
  const validMIDs = ['L1', 'M1', 'XL1', 'L28', 'M32', 'XL26', 'L8', 'XL7', 'L11', 'M11', 'XL11'];
  
  // Process data rows
  const laneStatusData = [];
  
  for (let i = 1; i < data.length; i++) { // Start from 1 to skip headers
    const row = data[i];
    const laneID = row[0];
    const zona = row[1];
    const quantity = row[2];
    const mid = row[3];
    const setting = row[4];
    const date = row[5];
    
    // Validate MID
    if (validMIDs.includes(mid)) {
      laneStatusData.push({
        laneID: laneID,
        zona: zona,
        quantity: quantity,
        mid: mid,
        setting: setting,
        date: Utilities.formatDate(new Date(date), Session.getScriptTimeZone(), 'yyyy-MM-dd')
      });
    }
  }
  
  return laneStatusData;
}




/**
 * Fungsi pembulatan kustom.
 * Jika desimal >= 0.4, bulatkan ke atas. Jika < 0.4, bulatkan ke bawah.
 *
 * @param {number} num - Angka yang akan dibulatkan.
 * @return {number} Angka yang telah dibulatkan.
 */
function customRound(num) {
  const floored = Math.floor(num);
  const decimal = num - floored;
  return decimal >= 0.4 ? floored + 1 : floored;
}

/**
 * Fungsi untuk mengambil data baru yang akan ditampilkan di tabel baru.
 * Mengambil data dari sheet "LANE STATUS", mengelompokkan berdasarkan MID (NAME PRODUCT),
 * menjumlahkan Quantity, dan menghitung ACTUAL STOCK / PALLET serta ACTUAL STOCK / BOX
 * dengan penyesuaian untuk Zona "E" atau "ECERAN" dan pembulatan kustom.
 *
 * @return {Array} Array of Arrays yang berisi [MID, NAME PRODUCT, ACTUAL STOCK / PALLET, ACTUAL STOCK / BOX]
 */
function getNewStockData() {
  // Definisikan urutan produk sesuai dengan nama produk di spreadsheet
  const orderedProducts = [
    "L11",
    "L1",
    "L28",
    "L8",
    "M11",
    "M1",
    "M32",
    "XL11",
    "XL1",
    "XL26",
    "XL7"
  ];

  // Definisikan mapping dari nama produk ke MID dan converter
  const productMappings = {
    "L11": { mid: "1150051", converter: 56 },
    "L1": { mid: "1050051", converter: 64 },
    "L28": { mid: "50055", converter: 32 },
    "L8": { mid: "50052", converter: 45 },
    "M11": { mid: "1150046", converter: 56 },
    "M1": { mid: "1050046", converter: 64 },
    "M32": { mid: "50050", converter: 32 },
    "XL11": { mid: "1150056", converter: 42 },
    "XL1": { mid: "1050056", converter: 49 },
    "XL26": { mid: "50060", converter: 32 },
    "XL7": { mid: "50057", converter: 45 } // Diperbarui dari 9 menjadi 45
  };

  // Inisialisasi map untuk menyimpan jumlah boxes per MID
  const stockMap = {};
  orderedProducts.forEach(productName => {
    stockMap[productName] = {
      boxes: 0
    };
  });

  // Buka sheet "LANE STATUS"
  const sheet = SpreadsheetApp.openById('1bH3_loER7TNhomI13gXuuowNA45sIKuO9xbQjw1-WY8').getSheetByName('LANE STATUS');
  const data = sheet.getDataRange().getValues();

  // Iterasi melalui setiap baris data, mulai dari baris kedua jika ada header
  for (let i = 1; i < data.length; i++) {
    const row = data[i];
    
    const zona = row[1] ? row[1].toString().trim().toUpperCase() : ''; // Kolom B: ZonaproductMappings
    const productName = row[3] ? row[3].toString().trim() : ''; // Kolom D: MID (Nama Produk)
    const quantity = parseInt(row[2], 10) || 0; // Kolom C: Quantity

    if (orderedProducts.includes(productName)) {
      const mapping = productMappings[productName];
      if (!mapping) {
        // Jika mapping tidak ditemukan, lewati produk ini
        continue;
      }
      const converter = mapping.converter;

      if (zona === "E" || zona === "ECERAN") {
        // Jika Zona adalah E atau ECERAN, tambahkan ke boxes langsung
        stockMap[productName].boxes += quantity;
      } else {
        // Jika Zona lain (misalnya, A atau B), konversi pallets ke boxes dan tambahkan
        stockMap[productName].boxes += quantity * converter;
      }
    }
  }

  // Siapkan data untuk tabel baru sesuai urutan produk
  const newStockData = orderedProducts.map(productName => {
    const mapping = productMappings[productName];
    if (!mapping) {
      // Jika mapping tidak ditemukan, lewati produk ini
      return [productName, "Mapping Tidak Ditemukan", 0, 0];
    }

    const mid = mapping.mid;
    const converter = mapping.converter;
    const totalBoxes = stockMap[productName].boxes;
    const palletsUnrounded = totalBoxes / converter;
    const totalPallets = customRound(palletsUnrounded); // Pembulatan kustom

    // Pastikan data valid
    const validPallet = Number.isInteger(totalPallets) && totalPallets >= 0;
    const validBox = Number.isInteger(totalBoxes) && totalBoxes >= 0;

    if (validPallet && validBox) {
      return [mid, productName, totalPallets, totalBoxes];
    } else {
      // Jika data tidak valid, tetapkan nilai 0
      return [mid, productName, 0, 0];
    }
  });

  return newStockData;
}



/**
 * Fungsi sementara untuk mengatur kata sandi admin awal.
 * Jalankan fungsi ini sekali saja dan hapus setelahnya.
 */
/* 
function initializeAdminPassword() {
  var initialPassword = 'Yaitu'; // Ganti dengan kata sandi yang diinginkan
  setInitialPassword(initialPassword);
}
*/


const SALT = 'Yaitu'; // Ganti dengan nilai salt yang kuat dan acak

/**
 * Function to save the setting value with password verification
 * @param {string} settingValue - The setting value selected by the admin
 * @param {string} password - The admin password entered by the user
 * @returns {Object} - Result object indicating success or failure
 */
function saveSetting(settingValue, password) {
  try {
    // Verify the password
    if (!verifyPassword(password)) {
      return { success: false, message: 'Incorrect password. Access denied.' };
    }

    // Validate settingValue
    const validSettings = ['1', '2']; // Tambahkan nilai yang valid sesuai kebutuhan
    if (!validSettings.includes(settingValue)) {
      return { success: false, message: 'Invalid setting value.' };
    }

    var scriptProperties = PropertiesService.getScriptProperties();
    scriptProperties.setProperty('currentSetting', settingValue);
    return { success: true };
  } catch (error) {
    return { success: false, message: 'Failed to save setting: ' + error.message };
  }
}

/**
 * Function to get the current setting value
 * @returns {string} - The current setting value or empty string if not set
 */
function getSetting() {
  try {
    var scriptProperties = PropertiesService.getScriptProperties();
    var settingValue = scriptProperties.getProperty('currentSetting');
    return settingValue || ""; // Return empty string if not set
  } catch (error) {
    return "";
  }
}

/**
 * Function to verify the admin password
 * @param {string} password - The password to verify
 * @returns {boolean} - True if password is correct, false otherwise
 */
function verifyPassword(password) {
  var scriptProperties = PropertiesService.getScriptProperties();
  var storedHashedPassword = scriptProperties.getProperty('adminPasswordHash');

  if (!storedHashedPassword) {
    throw new Error('Admin password has not been set. Please set it manually.');
  }

  // Hash the provided password with salt and compare
  var saltedPassword = SALT + password;
  var hashedPassword = Utilities.base64Encode(Utilities.computeDigest(Utilities.DigestAlgorithm.SHA_256, saltedPassword));
  return hashedPassword === storedHashedPassword;
}

/**
 * Function to set the initial admin password
 * Run this function manually once to set the admin password
 * @param {string} initialPassword - The initial password to set
 */
function setInitialPassword(initialPassword) {
  var scriptProperties = PropertiesService.getScriptProperties();
  var saltedPassword = SALT + initialPassword;
  var hashedPassword = Utilities.base64Encode(Utilities.computeDigest(Utilities.DigestAlgorithm.SHA_256, saltedPassword));
  scriptProperties.setProperty('adminPasswordHash', hashedPassword);
}



/* Moving Lane Builder */
// Function to get the data for Lane Status
function getDataLaneStatus() {
  const ss = SpreadsheetApp.openById('1bH3_loER7TNhomI13gXuuowNA45sIKuO9xbQjw1-WY8');
  const sheet = ss.getSheetByName('LANE STATUS');
  const data = sheet.getDataRange().getValues();

  // Helper function to format dates into 'YYYY-MM-DD' format
  function formatDateToString(date) {
    if (date instanceof Date) {
      return Utilities.formatDate(date, Session.getScriptTimeZone(), "yyyy-MM-dd");
    }
    return date; // If not a Date object, return as is
  }

  // Convert Date column to string format for easier display
  const formattedData = data.map(row => {
    if (row[5] instanceof Date) {
      row[5] = formatDateToString(row[5]); // Convert Date column (index 5) to string
    }
    return row;
  });

  return formattedData; // Return the formatted data
}

// Helper function to determine Max Pallet Based On Lane ID
function getMaxPallet(laneId) {
  const specialLanesA = ["11A", "17A", "23A"];
  const specialLanesB = ["10B", "22B"];
  if (specialLanesA.includes(laneId) || specialLanesB.includes(laneId)) {
    return 30;
  }
  return 75;
}

// Define mapping from MID to converter (Perbaikan sesuai Perintah 1)
const productMappings = {
  "L11": { converter: 56 },
  "L1": { converter: 64 },
  "L28": { converter: 32 },
  "L8": { converter: 45 },
  "M11": { converter: 56 },
  "M1": { converter: 64 },
  "M32": { converter: 32 },
  "XL11": { converter: 48 },
  "XL1": { converter: 49 },
  "XL26": { converter: 32 },
  "XL7": { converter: 45 } // Updated from 9 to 45
};

// Function to move data from Source to Target and log it to the "MOVING LOG" sheet
function moveDataWithLogging(sourceZona, sourceLane, targetZona, targetLane, transferQuantity, alasan = "") {
  try {
    const ss = SpreadsheetApp.openById('1bH3_loER7TNhomI13gXuuowNA45sIKuO9xbQjw1-WY8'); // Replace with your Spreadsheet ID
    const sheet = ss.getSheetByName('LANE STATUS'); // Replace with your LANE STATUS sheet
    if (!sheet) {
      throw new Error('Sheet "LANE STATUS" not found.');
    }
    const data = sheet.getDataRange().getValues();
    
    let sourceRowIndex = -1;
    let targetRowIndex = -1;

    // Locate source and target rows
    for (let i = 1; i < data.length; i++) { // Start from 1 to skip header
      let row = data[i];
      if (row[0].trim().toUpperCase() === sourceLane.trim().toUpperCase() && row[1].trim().toUpperCase() === sourceZona.trim().toUpperCase()) {
        sourceRowIndex = i + 1; // Spreadsheet rows are 1-based
      }
      if (row[0].trim().toUpperCase() === targetLane.trim().toUpperCase() && row[1].trim().toUpperCase() === targetZona.trim().toUpperCase()) {
        targetRowIndex = i + 1;
      }
    }

    if (sourceRowIndex === -1) {
      throw new Error(`Source data not found for Zona ${sourceZona} and Lane ${sourceLane}.`);
    }

    if (targetRowIndex === -1) {
      throw new Error(`Target data not found for Zona ${targetZona} and Lane ${targetLane}.`);
    }

    // Get data from source
    const sourceData = data[sourceRowIndex - 1];
    let [laneSumber, zonaSumber, quantitySumber, midSumber, settingSumber, dateSumber] = sourceData;

    quantitySumber = parseInt(quantitySumber, 10);
    if (isNaN(quantitySumber) || quantitySumber <= 0) {
      throw new Error(`No Quantity data available to transfer from Zona ${sourceZona} and Lane ${sourceLane}.`);
    }

    // Validate transferQuantity
    transferQuantity = parseInt(transferQuantity, 10);
    if (isNaN(transferQuantity) || transferQuantity < 1) {
      throw new Error('Transfer Quantity must be valid.');
    }

    if (transferQuantity > quantitySumber) {
      throw new Error(`Transfer Quantity (${transferQuantity}) exceeds source Quantity (${quantitySumber}).`);
    }

    // Handle the case where source and target are the same
    if (
      sourceZona.trim().toUpperCase() === targetZona.trim().toUpperCase() &&
      sourceLane.trim().toUpperCase() === targetLane.trim().toUpperCase()
    ) {
      // Quantities remain the same; log the transfer
      const logSheet = ss.getSheetByName('MOVING LOG') || ss.insertSheet('MOVING LOG');
      
      // If log sheet is empty, add headers
      if (logSheet.getLastRow() === 0) {
        logSheet.appendRow(['Timestamp', 'Zona Sumber', 'Lane Sumber', 'Zona Target', 'Lane Target', 'Alasan', 'Lane', 'Zona', 'Quantity', 'MID', 'Setting', 'Date']);
      }

      // Log the transfer
      const timestamp = new Date();
      logSheet.appendRow([timestamp, sourceZona, sourceLane, targetZona, targetLane, alasan, sourceLane, sourceZona, transferQuantity, midSumber, settingSumber, dateSumber]);

      Logger.log('Transfer within the same lane and zone completed. Quantities remain unchanged.');
      return 'Transfer within the same lane and zone completed. Quantities remain unchanged.';
    }

    // **Penambahan Logika untuk Menolak Transfer dari E ke A/B**
    if (
      sourceZona.trim().toUpperCase() === 'E' &&
      (targetZona.trim().toUpperCase() === 'A' || targetZona.trim().toUpperCase() === 'B')
    ) {
      throw new Error('Pemindahan data dari Zona E ke Zona A/B tidak diizinkan.');
    }

    // Additional logic for transferring to a different zone (Command 5)
    let isDifferentZone = sourceZona.trim().toUpperCase() !== targetZona.trim().toUpperCase();
    if (isDifferentZone && alasan.trim() === "") {
      throw new Error('Transferring to a different zone requires a reason.');
    }

    // Get data from target
    const targetData = data[targetRowIndex - 1];
    let [laneTargetCheck, zonaTargetCheck, quantityTarget, midTarget, settingTarget, dateTarget] = targetData;

    quantityTarget = parseInt(quantityTarget, 10);
    if (isNaN(quantityTarget)) {
      quantityTarget = 0;
    }

    // Additional logic for conversion when transferring from A/B to E (Command 6)
    let conversionFactor = 1;
    let converted = false;
    if ((sourceZona.trim().toUpperCase() === 'A' || sourceZona.trim().toUpperCase() === 'B') && targetZona.trim().toUpperCase() === 'E') {
      // Find converter based on MID
      if (productMappings[midSumber]) {
        conversionFactor = productMappings[midSumber].converter;
        converted = true;
      } else {
        throw new Error(`No converter found for MID ${midSumber}.`);
      }
    }

    let actualTransferQuantity = transferQuantity;
    let actualTransferQuantityConverted = transferQuantity;

    if (converted) {
      actualTransferQuantityConverted = transferQuantity * conversionFactor;
    }

    // If MID in target is same as source, perform quantity addition
    if (midTarget && midTarget.trim().toUpperCase() === midSumber.trim().toUpperCase()) {
      // Determine max pallets in target lane
      const maxPallet = getMaxPallet(targetLane.trim().toUpperCase());

      // Calculate available capacity in target
      const availableCapacity = maxPallet - quantityTarget;

      if (availableCapacity <= 0) {
        throw new Error(`Target Lane ${targetLane} is full with Quantity ${quantityTarget}.`);
      }

      // Determine the actual transfer quantity
      const actualTransfer = Math.min(actualTransferQuantityConverted, availableCapacity);

      // Update Quantity in target
      const newQuantityTarget = quantityTarget + actualTransfer;
      sheet.getRange(targetRowIndex, 3).setValue(newQuantityTarget); // Quantity

      // If there's Setting and Date to transfer, update them accordingly
      sheet.getRange(targetRowIndex, 5).setValue(settingSumber); // Setting
      sheet.getRange(targetRowIndex, 6).setValue(dateSumber);    // Date

      // Calculate quantity to deduct from source
      let quantityToDeduct = converted ? Math.ceil(actualTransfer / conversionFactor) : transferQuantity;
      const newQuantitySumber = quantitySumber - quantityToDeduct;
      sheet.getRange(sourceRowIndex, 3).setValue(newQuantitySumber); // Quantity

      // If there's remaining quantity in source, retain Setting and Date
      if (newQuantitySumber > 0) {
        sheet.getRange(sourceRowIndex, 5).setValue(settingSumber); // Setting
        sheet.getRange(sourceRowIndex, 6).setValue(dateSumber);    // Date
      } else {
        // If no remaining quantity, clear MID, Setting, and Date
        sheet.getRange(sourceRowIndex, 3).setValue(0); // Quantity set to 0
        sheet.getRange(sourceRowIndex, 4).setValue(''); // Clear MID
        sheet.getRange(sourceRowIndex, 5).setValue(''); // Clear Setting
        sheet.getRange(sourceRowIndex, 6).setValue(''); // Clear Date
      }

      // Log the transfer
      const logSheet = ss.getSheetByName('MOVING LOG') || ss.insertSheet('MOVING LOG');
      
      // If log sheet is empty, add headers
      if (logSheet.getLastRow() === 0) {
        logSheet.appendRow(['Timestamp', 'Zona Sumber', 'Lane Sumber', 'Zona Target', 'Lane Target', 'Alasan', 'Lane', 'Zona', 'Quantity', 'MID', 'Setting', 'Date']);
      }

      // Log the transferred data
      const timestamp = new Date();
      logSheet.appendRow([timestamp, sourceZona, sourceLane, targetZona, targetLane, alasan, sourceLane, sourceZona, actualTransfer, midSumber, settingSumber, dateSumber]);

      Logger.log(`Data successfully transferred: ${actualTransfer} from Zona ${sourceZona} Lane ${sourceLane} to Zona ${targetZona} Lane ${targetLane}.`);
      
      return `Data successfully transferred: ${actualTransfer} from Zona ${sourceZona} Lane ${sourceLane} to Zona ${targetZona} Lane ${targetLane}.`;
    } else {
      // If MID in target is different or empty
      if (midTarget && midTarget.trim() !== "") {
        throw new Error(`Target Lane ${targetLane} already has a different MID. Cannot transfer data.`);
      }

      // Determine max pallets in target lane
      const maxPallet = getMaxPallet(targetLane.trim().toUpperCase());

      // Calculate available capacity in target
      const availableCapacity = maxPallet - quantityTarget;

      if (availableCapacity <= 0) {
        throw new Error(`Target Lane ${targetLane} is full with Quantity ${quantityTarget}.`);
      }

      // Determine the actual transfer quantity
      const actualTransfer = Math.min(actualTransferQuantityConverted, availableCapacity);

      // Update Quantity in target
      const newQuantityTarget = quantityTarget + actualTransfer;
      sheet.getRange(targetRowIndex, 3).setValue(newQuantityTarget); // Quantity

      // Update MID, Setting, and Date in target
      sheet.getRange(targetRowIndex, 4).setValue(midSumber);        // MID
      sheet.getRange(targetRowIndex, 5).setValue(settingSumber);    // Setting
      sheet.getRange(targetRowIndex, 6).setValue(dateSumber);       // Date

      // Calculate quantity to deduct from source
      let quantityToDeduct = converted ? Math.ceil(actualTransfer / conversionFactor) : transferQuantity;
      const newQuantitySumber = quantitySumber - quantityToDeduct;
      sheet.getRange(sourceRowIndex, 3).setValue(newQuantitySumber); // Quantity

      // If there's remaining quantity in source, retain Setting and Date
      if (newQuantitySumber > 0) {
        sheet.getRange(sourceRowIndex, 5).setValue(settingSumber); // Setting
        sheet.getRange(sourceRowIndex, 6).setValue(dateSumber);    // Date
      } else {
        // If no remaining quantity, clear MID, Setting, and Date
        sheet.getRange(sourceRowIndex, 3).setValue(0); // Quantity set to 0
        sheet.getRange(sourceRowIndex, 4).setValue(''); // Clear MID
        sheet.getRange(sourceRowIndex, 5).setValue(''); // Clear Setting
        sheet.getRange(sourceRowIndex, 6).setValue(''); // Clear Date
      }

      // Log the transfer
      const logSheet = ss.getSheetByName('MOVING LOG') || ss.insertSheet('MOVING LOG');
      
      // If log sheet is empty, add headers
      if (logSheet.getLastRow() === 0) {
        logSheet.appendRow(['Timestamp', 'Zona Sumber', 'Lane Sumber', 'Zona Target', 'Lane Target', 'Alasan', 'Lane', 'Zona', 'Quantity', 'MID', 'Setting', 'Date']);
      }

      // Log the transferred data
      const timestamp = new Date();
      logSheet.appendRow([timestamp, sourceZona, sourceLane, targetZona, targetLane, alasan, sourceLane, sourceZona, actualTransfer, midSumber, settingSumber, dateSumber]);

      Logger.log(`Data successfully transferred: ${actualTransfer} from Zona ${sourceZona} Lane ${sourceLane} to Zona ${targetZona} Lane ${targetLane}.`);

      return `Data successfully transferred: ${actualTransfer} from Zona ${sourceZona} Lane ${sourceLane} to Zona ${targetZona} Lane ${targetLane}.`;
    }
  } catch (error) {
    Logger.log(`Error in moveDataWithLogging: ${error.message}`);
    throw new Error(`Unable to transfer data: ${error.message}`);
  }
}





/* Builder SYNC */
/**
 * Fungsi utama untuk menyinkronkan data dari "SO RAW" ke "LANE STATUS"
 * @param {string} selectedSession - Sesi yang dipilih oleh pengguna ('morning' atau 'afternoon')
 */
function synchronizeData(selectedSession) {
  const ss = SpreadsheetApp.openById("1bH3_loER7TNhomI13gXuuowNA45sIKuO9xbQjw1-WY8"); // ID Spreadsheet Anda
  const soRawSheet = ss.getSheetByName("SO RAW");
  const laneStatusSheet = ss.getSheetByName("LANE STATUS");
  
  if (!soRawSheet || !laneStatusSheet) {
    throw new Error("Pastikan kedua sheet 'SO RAW' dan 'LANE STATUS' ada di spreadsheet.");
  }
  
  // Mengambil semua data dari "SO RAW" (tanpa header)
  const soRawData = soRawSheet.getDataRange().getValues();
  
  // Mengambil semua data dari "LANE STATUS" (dengan header)
  const laneStatusData = laneStatusSheet.getDataRange().getValues();
  
  // Mendapatkan header dari "LANE STATUS" dan membuat mapping indeks kolom
  const laneStatusHeader = laneStatusData[0].map(header => header.toString().trim().toLowerCase());
  const laneIdxStatus = laneStatusHeader.indexOf("lane");
  const quantityIdxStatus = laneStatusHeader.indexOf("quantity");
  const midIdxStatus = laneStatusHeader.indexOf("mid");
  
  if (laneIdxStatus === -1 || quantityIdxStatus === -1 || midIdxStatus === -1) {
    throw new Error("Pastikan sheet 'LANE STATUS' memiliki kolom 'Lane', 'Quantity', dan 'MID'.");
  }
  
  // Membuat mapping lane di "LANE STATUS" untuk akses cepat
  const laneStatusMap = {};
  for (let i = 1; i < laneStatusData.length; i++) {
    const laneName = laneStatusData[i][laneIdxStatus].toString().trim();
    if (laneName) {
      laneStatusMap[laneName] = i; // Menyimpan indeks baris (0-based)
    }
  }
  
  // Mendapatkan tanggal hari ini dalam format "dd/MM/yyyy"
  const now = new Date();
  const timeZone = ss.getSpreadsheetTimeZone();
  const todayStr = Utilities.formatDate(now, timeZone, "dd/MM/yyyy");
  
  // Menentukan sesi berdasarkan pilihan pengguna
  let session = selectedSession;
  if (!session) {
    const currentHour = now.getHours();
    if (currentHour >= 1 && currentHour < 13) {
      session = 'morning'; // Session 1: 01:00 AM - 12:59 PM
    } else if (currentHour >= 13 && currentHour < 24) {
      session = 'afternoon'; // Session 2: 01:00 PM - 11:59 PM
    } else {
      return "Skrip hanya berjalan antara 01:00 AM hingga 11:59 PM.";
    }
  }
  
  // Mendapatkan waktu batasan sesi
  let sessionStartHour, sessionEndHour;
  if (session === 'morning') {
    sessionStartHour = 1;
    sessionEndHour = 13; // 12:59 PM
  } else if (session === 'afternoon') {
    sessionStartHour = 13;
    sessionEndHour = 24; // 11:59 PM
  } else {
    throw new Error("Sesi yang dipilih tidak valid. Pilih 'morning' atau 'afternoon'.");
  }
  
  // Membuat mapping dari nama lane di "SO RAW" ke nama lane di "LANE STATUS"
  const laneMapping = getLaneMapping();
  
  // Menyiapkan array untuk perubahan Quantity dan MID
  const quantityUpdates = [];
  const midUpdates = [];
  
  // Mengiterasi data dari "SO RAW"
  for (let i = 0; i < soRawData.length; i++) { // Mulai dari 0 karena tidak ada header
    const row = soRawData[i];
    const soRawLane = row[0].toString().trim(); // Kolom A: Lane
    let soRawMID = row[2].toString().trim();  // Kolom C: MID
    const soRawQuantity = row[3];              // Kolom D: Quantity
    const soRawDate = row[5];                  // Kolom F: Date
    
    // Mengubah nama lane ke format "LANE STATUS" menggunakan mapping
    const mappedLane = laneMapping[soRawLane];
    if (!mappedLane) {
      Logger.log(`Tidak ada mapping untuk lane: ${soRawLane}`);
      continue; // Lewati jika tidak ada mapping
    }
    
    // Memeriksa apakah lane ada di "LANE STATUS"
    const laneStatusRow = laneStatusMap[mappedLane];
    if (laneStatusRow === undefined) {
      Logger.log(`Tidak ditemukan lane di 'LANE STATUS' untuk: ${mappedLane}`);
      continue; // Lewati jika lane tidak ditemukan
    }
    
    // Memeriksa tanggal dan sesi dari "SO RAW"
    const soRawDateObj = new Date(soRawDate);
    if (isNaN(soRawDateObj)) {
      Logger.log(`Tanggal tidak valid untuk lane: ${soRawLane} pada baris ${i + 1}`);
      continue; // Lewati jika tanggal tidak valid
    }
    
    const soRawDateStr = Utilities.formatDate(soRawDateObj, timeZone, "dd/MM/yyyy");
    const soRawHour = soRawDateObj.getHours();
    
    // Tentukan sesi dari data
    let dataSession;
    if (soRawHour >= 1 && soRawHour < 13) {
      dataSession = 'morning';
    } else if (soRawHour >= 13 && soRawHour < 24) {
      dataSession = 'afternoon';
    } else {
      dataSession = 'unknown';
    }
    
    // Hanya proses data yang sesuai dengan sesi yang dipilih dan tanggal hari ini
    if (soRawDateStr === todayStr && dataSession === session) {
      // Pengecekan nilai MID
      if (soRawMID === "Lane Kosong") {
        soRawMID = ''; // Atau bisa menggunakan null atau undefined jika diinginkan
      }
      
      // Menyimpan perubahan Quantity
      quantityUpdates.push({ row: laneStatusRow + 1, value: soRawQuantity });
      
      // Menyimpan perubahan MID jika tidak kosong
      // Jika Anda memilih untuk tidak menulis nilai MID sama sekali saat "Lane Kosong", Anda bisa menambahkan kondisi berikut:
      if (soRawMID !== '') {
        midUpdates.push({ row: laneStatusRow + 1, value: soRawMID });
      } else {
        // Jika ingin menghapus nilai MID di sheet "LANE STATUS" saat "Lane Kosong"
        midUpdates.push({ row: laneStatusRow + 1, value: '' });
      }
    }
  }
  
  // Melakukan batch update untuk Quantity
  if (quantityUpdates.length > 0) {
    const quantityRange = laneStatusSheet.getRange(2, quantityIdxStatus + 1, laneStatusData.length - 1, 1);
    const quantityValues = quantityRange.getValues();
    quantityUpdates.forEach(update => {
      quantityValues[update.row - 2][0] = update.value;
    });
    quantityRange.setValues(quantityValues);
  }
  
  // Melakukan batch update untuk MID
  if (midUpdates.length > 0) {
    const midRange = laneStatusSheet.getRange(2, midIdxStatus + 1, laneStatusData.length - 1, 1);
    const midValues = midRange.getValues();
    midUpdates.forEach(update => {
      midValues[update.row - 2][0] = update.value;
    });
    midRange.setValues(midValues);
  }
  
  // Menyimpan waktu sinkronisasi terakhir ke PropertiesService
  const properties = PropertiesService.getScriptProperties();
  const lastSyncTime = Utilities.formatDate(now, timeZone, "dd/MM/yyyy HH:mm:ss");
  properties.setProperty('LAST_SYNC_TIME', lastSyncTime);
  
  return `Sinkronisasi selesai pada sesi ${session}. ${quantityUpdates.length} Lane diperbarui.`;
}

/**
 * Fungsi untuk mengambil waktu sinkronisasi terakhir
 * @returns {string} Waktu sinkronisasi terakhir
 */
function getLastSyncTime() {
  const properties = PropertiesService.getScriptProperties();
  const lastSyncTime = properties.getProperty('LAST_SYNC_TIME');
  return lastSyncTime ? lastSyncTime : "Belum pernah disinkronkan.";
}

/**
 * Fungsi untuk membuat mapping lane dari "SO RAW" ke "LANE STATUS"
 */
function getLaneMapping() {
  return {
    "LANE 1ECERAN": "1E",
    "LANE 2ECERAN": "2E",
    "LANE 3ECERAN": "3E",
    "LANE 4ECERAN": "4E",
    "LANE 5ECERAN": "5E",
    "LANE 6ECERAN": "6E",
    "LANE 7ECERAN": "7E",
    "LANE 8ECERAN": "8E",
    "LANE 9ECERAN": "9E",
    "LANE 10ECERAN": "10E",
    "LANE 11ECERAN": "11E",
    "LANE 12ECERAN": "12E",
    "LANE 13ECERAN": "13E",
    "LANE 14ECERAN": "14E",
    "LANE 15ECERAN": "15E",
    "LANE 1B": "1B",
    "LANE 2B": "2B",
    "LANE 3B": "3B",
    "LANE 4B": "4B",
    "LANE 5B": "5B",
    "LANE 6B": "6B",
    "LANE 7B": "7B",
    "LANE 8B": "8B",
    "LANE 9B": "9B",
    "LANE 10B": "10B",
    "LANE 11B": "11B",
    "LANE 12B": "12B",
    "LANE 13B": "13B",
    "LANE 14B": "14B",
    "LANE 15B": "15B",
    "LANE 16B": "16B",
    "LANE 17B": "17B",
    "LANE 18B": "18B",
    "LANE 19B": "19B",
    "LANE 20B": "20B",
    "LANE 21B": "21B",
    "LANE 22B": "22B",
    "LANE 23B": "23B",
    "LANE 24B": "24B",
    "LANE 25B": "25B",
    "LANE 26B": "26B",
    "LANE 1A": "1A",
    "LANE 2A": "2A",
    "LANE 3A": "3A",
    "LANE 4A": "4A",
    "LANE 5A": "5A",
    "LANE 6A": "6A",
    "LANE 7A": "7A",
    "LANE 8A": "8A",
    "LANE 9A": "9A",
    "LANE 10A": "10A",
    "LANE 11A": "11A",
    "LANE 12A": "12A",
    "LANE 13A": "13A",
    "LANE 14A": "14A",
    "LANE 15A": "15A",
    "LANE 16A": "16A",
    "LANE 17A": "17A",
    "LANE 18A": "18A",
    "LANE 19A": "19A",
    "LANE 20A": "20A",
    "LANE 21A": "21A",
    "LANE 22A": "22A",
    "LANE 23A": "23A",
    "LANE 24A": "24A",
    "LANE 25A": "25A",
    "LANE 26A": "26A"
    // Tambahkan mapping lainnya jika diperlukan
  };
}

/**
 * Fungsi untuk sinkronisasi sesi pagi
 */
function synchronizeMorning() {
  synchronizeData('morning');
}

/**
 * Fungsi untuk sinkronisasi sesi sore
 */
function synchronizeAfternoon() {
  synchronizeData('afternoon');
}



/* AUTOMATION OUTBOUND */

// **Konstanta dan Mapping MID**
const MAIN_SPREADSHEET_ID = '1bH3_loER7TNhomI13gXuuowNA45sIKuO9xbQjw1-WY8'; // Spreadsheet Utama
const SECOND_SPREADSHEET_ID = '1ClW9ZK626TNGGuTXGTQE-6q4P8nCO7r2lt93QsgdxdM'; // Spreadsheet Kedua (ARIS)
const MAIN_SHEET_NAME = 'LANE STATUS'; // Nama sheet di Spreadsheet Utama
const SECOND_SHEET_NAME = 'DATA'; // Nama sheet di Spreadsheet Kedua
const PICKING_LIST_SHEET_NAME = 'PICKING LIST';
const BOOKINGS_SHEET_NAME = 'BOOKINGS';
const OUTBOUND_SHEET_NAME = 'OUTBOUND';

/**
 * Mapping dari MID Utama ke MID Kedua dan Converter (Box per Pallet)
 */
const MIDMapping = { 
  "L11": { secondMID: "1150051", converter: 56 },
  "L1": { secondMID: "1050051", converter: 64 },
  "L28": { secondMID: "50055", converter: 32 },
  "L8": { secondMID: "50052", converter: 45 },
  "M11": { secondMID: "1150046", converter: 56 },
  "M1": { secondMID: "1050046", converter: 64 },
  "M32": { secondMID: "50050", converter: 32 },
  "XL11": { secondMID: "1150056", converter: 42 },
  "XL1": { secondMID: "1050056", converter: 49 },
  "XL26": { secondMID: "50060", converter: 32 },
  "XL7": { secondMID: "50057", converter: 45 }
  // Pastikan tidak ada entry untuk Lane seperti "2A"
};

/**
 * Function to get column index with case-insensitive header
 * @param {Array} headers - Array of header names
 * @param {String} columnName - Name of the column to find
 * @returns {Number} - Index of the column, or -1 if not found
 */
function getColumnIndex(headers, columnName) {
  for (let i = 0; i < headers.length; i++) {
    if (headers[i].toString().trim().toLowerCase() === columnName.toLowerCase()) {
      return i;
    }
  }
  return -1;
}

/**
 * Function to generate a unique Booking ID
 * @returns {String} - Unique Booking ID
 */
function generateBookingID() {
  const timestamp = new Date().getTime();
  const randomNum = Math.floor(Math.random() * 1000);
  return `BK-${timestamp}-${randomNum}`;
}

/**
 * Function to get the count of active bookings from the "BOOKINGS" sheet
 * @returns {Number} - Count of active bookings
 */
function getBookingCount() {
  const ss = SpreadsheetApp.openById(MAIN_SPREADSHEET_ID);
  const bookingsSheet = ss.getSheetByName(BOOKINGS_SHEET_NAME);
  if (!bookingsSheet) {
    return 0;
  }
  const data = bookingsSheet.getDataRange().getValues();
  const headers = data[0];
  const statusIndex = headers.findIndex(header => header.toString().trim().toLowerCase() === 'status');
  
  if (statusIndex === -1) {
    throw new Error('Kolom "Status" tidak ditemukan di sheet BOOKINGS.');
  }

  // Count the number of bookings with status 'Aktif'
  const activeBookings = data.slice(1).filter(row => row[statusIndex].toString().trim().toLowerCase() === 'aktif');
  return activeBookings.length;
}

/**
 * Function to get all active bookings from the "BOOKINGS" sheet
 * @returns {Array} Array of booking objects
 */
function getAllActiveBookings() {
  const ss = SpreadsheetApp.openById(MAIN_SPREADSHEET_ID);
  const bookingsSheet = ss.getSheetByName(BOOKINGS_SHEET_NAME);
  if (!bookingsSheet) {
    return [];
  }
  const data = bookingsSheet.getDataRange().getValues();
  const headers = data[0];
  const bookingHeaderMap = headers.map(header => header.toString().trim().toLowerCase());
  const statusIndex = bookingHeaderMap.indexOf('status');
  
  if (statusIndex === -1) {
    throw new Error('Kolom "Status" tidak ditemukan di sheet BOOKINGS.');
  }

  const activeBookings = data.slice(1).filter(row => row[statusIndex].toString().trim().toLowerCase() === 'aktif');

  return activeBookings.map(row => {
    let booking = {};
    for (let i = 0; i < bookingHeaderMap.length; i++) {
      booking[bookingHeaderMap[i]] = row[i];
    }
    return booking;
  });
}

/**
 * Function to book outbound orders
 * @param {Array} outboundOrders - Array of objects {mid, lane}
 * @returns {Object} Result object with status and bookedOrders
 */
function bookOutboundOrders(outboundOrders) {
  const ss = SpreadsheetApp.openById(MAIN_SPREADSHEET_ID);
  let bookingsSheet = ss.getSheetByName(BOOKINGS_SHEET_NAME);
  if (!bookingsSheet) {
    bookingsSheet = ss.insertSheet(BOOKINGS_SHEET_NAME);
    bookingsSheet.appendRow(['Booking ID', 'MID', 'Lane', 'Zona', 'Quantity (Pallet)', 'Date', 'Status']);
  }

  const sheet = ss.getSheetByName(MAIN_SHEET_NAME);
  const dataRange = sheet.getDataRange();
  const data = dataRange.getValues();
  const headers = data[0];

  const laneIndex = getColumnIndex(headers, 'Lane');
  const zonaIndex = getColumnIndex(headers, 'Zona');
  const midIndex = getColumnIndex(headers, 'MID');
  const quantityIndex = getColumnIndex(headers, 'Quantity'); // Pastikan kolom Quantity ada
  const dateIndex = getColumnIndex(headers, 'Date');

  // Validate that all necessary columns exist
  if (laneIndex === -1 || zonaIndex === -1 || midIndex === -1 || quantityIndex === -1 || dateIndex === -1) {
    throw new Error('Pastikan sheet memiliki kolom "Lane", "Zona", "MID", "Quantity", dan "Date".');
  }

  // Get all active bookings
  const bookingsData = bookingsSheet.getDataRange().getValues();
  const bookingsHeaders = bookingsData[0];
  const statusIndexBooking = getColumnIndex(bookingsHeaders, 'Status');
  const laneIndexBooking = getColumnIndex(bookingsHeaders, 'Lane');

  if (statusIndexBooking === -1 || laneIndexBooking === -1) {
    throw new Error('Pastikan sheet BOOKINGS memiliki kolom "Status" dan "Lane".');
  }

  const activeBookings = bookingsData.slice(1).filter(row => row[statusIndexBooking].toString().trim().toLowerCase() === 'aktif');
  const bookedLanes = activeBookings.map(row => row[laneIndexBooking]);

  let bookedOrders = [];
  let skippedBookings = [];

  outboundOrders.forEach(order => {
    const { mid, lane } = order;

    // Check if lane is already booked
    if (bookedLanes.includes(lane)) {
      skippedBookings.push({
        mid: mid,
        lane: lane,
        reason: 'Lane sudah dibooking.'
      });
      return; // Skip booking this order
    }

    // Cari converter berdasarkan MID
    const mappingInfo = MIDMapping[mid];
    if (!mappingInfo) {
      skippedBookings.push({
        mid: mid,
        lane: lane,
        reason: `Tidak ada converter yang didefinisikan untuk MID ${mid}.`
      });
      return; // Skip booking this order
    }

    // Cari baris di sheet utama yang cocok dengan MID dan Lane
    const matchingRows = data.slice(1).filter(row => 
      row[midIndex] === mid && 
      row[laneIndex] === lane && 
      Number(row[quantityIndex]) > 0
    );

    if (matchingRows.length === 0) {
      skippedBookings.push({
        mid: mid,
        lane: lane,
        reason: `Data untuk MID ${mid} di Lane ${lane} tidak tersedia atau Quantity sudah 0.`
      });
      return; // Skip booking this order
    }

    // Cari baris dengan tanggal paling awal (FIFO)
    matchingRows.sort((a, b) => {
      const dateA = rowHasDate(a, dateIndex) ? new Date(a[dateIndex]) : new Date('9999-12-31');
      const dateB = rowHasDate(b, dateIndex) ? new Date(b[dateIndex]) : new Date('9999-12-31');
      return dateA - dateB;
    });

    const firstMatchingRow = matchingRows[0];
    const zona = firstMatchingRow[zonaIndex];
    const date = firstMatchingRow[dateIndex] ? formatDate(firstMatchingRow[dateIndex]) : 'N/A';
    const quantity = Number(firstMatchingRow[quantityIndex]);

    if (quantity <= 0) {
      skippedBookings.push({
        mid: mid,
        lane: lane,
        reason: `Quantity untuk MID ${mid} di Lane ${lane} tidak tersedia atau 0.`
      });
      return; // Skip booking this order
    }

    // Generate unique Booking ID
    const bookingID = generateBookingID();

    // Append booking data ke BOOKINGS sheet dengan Status "Aktif"
    bookingsSheet.appendRow([bookingID, mid, lane, zona, quantity, date, 'Aktif']);

    // Tambahkan ke array bookedOrders
    bookedOrders.push({
      bookingID: bookingID,
      mid: mid,
      lane: lane,
      zona: zona,
      quantity: quantity, // Quantity dalam Pallet
      date: date,
      status: 'Aktif'
    });

    // Add the lane to bookedLanes to prevent duplicate in the same request
    bookedLanes.push(lane);
  });

  let response = {
    success: true,
    bookedOrders: bookedOrders
  };

  if (skippedBookings.length > 0) {
    response.message = 'Beberapa lane sudah dibooking dan tidak dapat diproses.';
    response.skippedBookings = skippedBookings;
  }

  return response;
}

/**
 * Function to release bookings and deduct from stock following FIFO based on Booking Date
 * @returns {Object} Result object dengan status dan pickingList atau pesan error
 */
function releaseBookings() {
  // Menggunakan LockService untuk mencegah akses bersamaan
  var lock = LockService.getScriptLock();
  try {
    lock.waitLock(30000); // Tunggu hingga lock tersedia, timeout dalam 30 detik
  } catch (e) {
    throw new Error('Tidak dapat mengakses server saat ini. Silakan coba lagi nanti.');
  }

  try {
    const ssMain = SpreadsheetApp.openById(MAIN_SPREADSHEET_ID);
    const bookingsSheet = ssMain.getSheetByName(BOOKINGS_SHEET_NAME);
    if (!bookingsSheet) {
      return {
        success: false,
        message: 'Tidak ada booking untuk direlease.'
      };
    }

    const bookingsData = bookingsSheet.getDataRange().getValues();
    const bookingsHeaders = bookingsData[0];
    let bookings = bookingsData.slice(1);

    if (bookings.length === 0) {
      return {
        success: false,
        message: 'Tidak ada booking untuk direlease.'
      };
    }

    const sheetMain = ssMain.getSheetByName(MAIN_SHEET_NAME);
    const dataRangeMain = sheetMain.getDataRange();
    const dataMain = dataRangeMain.getValues();
    const headersMain = dataMain[0];

    const laneIndex = getColumnIndex(headersMain, 'Lane');
    const zonaIndex = getColumnIndex(headersMain, 'Zona');
    const quantityIndex = getColumnIndex(headersMain, 'Quantity');
    const midIndex = getColumnIndex(headersMain, 'MID');
    const dateIndex = getColumnIndex(headersMain, 'Date');

    const outboundSheet = ssMain.getSheetByName(OUTBOUND_SHEET_NAME);
    if (!outboundSheet) {
      throw new Error(`Sheet "${OUTBOUND_SHEET_NAME}" tidak ditemukan di Spreadsheet Utama.`);
    }

    const ssSecond = SpreadsheetApp.openById(SECOND_SPREADSHEET_ID);
    const sheetSecond = ssSecond.getSheetByName(SECOND_SHEET_NAME);
    if (!sheetSecond) {
      return {
        success: false,
        message: `Sheet dengan nama "${SECOND_SHEET_NAME}" tidak ditemukan di spreadsheet kedua.`
      };
    }

    const dataRangeSecond = sheetSecond.getDataRange();
    const dataSecond = dataRangeSecond.getValues();
    const headersSecond = dataSecond[0];

    const dateSecondIndex = getColumnIndex(headersSecond, 'Date');
    const midSecondIndex = getColumnIndex(headersSecond, 'MID');
    const qtyOkSecondIndex = getColumnIndex(headersSecond, 'QTY OK');
    const responseSecondIndex = getColumnIndex(headersSecond, 'Response');

    const today = formatDate(new Date());
    Logger.log('Today: ' + today);

    let pickingList = [];
    let insufficientItems = [];
    let outboundEntries = []; // Menyimpan entri untuk ditambahkan ke sheet OUTBOUND
    let rowsToDelete = []; // Menyimpan nomor baris untuk dihapus dari BOOKINGS

    const bookingHeaderMap = bookingsHeaders.map(header => header.toString().trim().toLowerCase());
    const statusIndexBooking = bookingHeaderMap.indexOf('status');
    const bookingIDIndex = bookingHeaderMap.indexOf('booking id');
    const quantityBookingIndex = bookingHeaderMap.indexOf('quantity (pallet)');
    const bookingDateIndex = bookingHeaderMap.indexOf('date'); // Asumsikan ada kolom 'Date' di BOOKINGS

    if (bookingIDIndex === -1 || quantityBookingIndex === -1 || bookingDateIndex === -1) {
      throw new Error('Pastikan sheet BOOKINGS memiliki kolom "Booking ID", "Quantity (Pallet)", dan "Date".');
    }

    // ------------------- LOGIKA BARU UNTUK PRIORITAS berdasarkan "TRIAL DATA" -------------------

    // 1. Dapatkan urutan secondMID dari sheet "TRIAL DATA" sesuai dengan urutan baris
    const secondMIDOrder = [];
    const trialDataRows = dataSecond.slice(1); // Mengabaikan header

    trialDataRows.forEach(row => {
      const secondMID = row[midSecondIndex].toString().trim();
      if (secondMID && !secondMIDOrder.includes(secondMID)) {
        secondMIDOrder.push(secondMID);
      }
    });

    // 2. Buat peta prioritas untuk secondMID berdasarkan urutan di "TRIAL DATA"
    const secondMIDPriorityMap = {};
    secondMIDOrder.forEach((mid, index) => {
      secondMIDPriorityMap[mid] = index + 1; // Prioritas dimulai dari 1
    });

    // 3. Tambahkan prioritas dan tanggal booking ke setiap booking, serta nomor baris asli
    const processedBookings = bookings.map((booking, index) => {
      const bookingMID = booking[getColumnIndex(bookingsHeaders, 'mid')];
      const mappingInfo = MIDMapping[bookingMID];
      let priority = Number.MAX_SAFE_INTEGER; // Prioritas rendah jika tidak ditemukan
      if (mappingInfo) {
        const secondMID = mappingInfo.secondMID;
        priority = secondMIDPriorityMap[secondMID] || Number.MAX_SAFE_INTEGER;
      }

      // Tambahkan field tanggal booking untuk pengurutan
      const bookingDateValue = booking[bookingDateIndex];
      let bookingDate = new Date('9999-12-31'); // Tanggal default jika tidak ada
      if (rowHasDate(booking, bookingDateIndex)) {
        if (typeof bookingDateValue === 'string') {
          bookingDate = parseDate(bookingDateValue);
        } else if (bookingDateValue instanceof Date) {
          bookingDate = bookingDateValue;
        }
      }

      return {
        data: booking,
        priority: priority,
        bookingDate: bookingDate,
        sheetRowNumber: index + 2 // +2 karena slice dimulai dari 1 dan indeks dimulai dari 0
      };
    });

    // 4. Urutkan bookings berdasarkan prioritas secondMID dan kemudian tanggal booking (FIFO)
    processedBookings.sort((a, b) => {
      if (a.priority < b.priority) return -1;
      if (a.priority > b.priority) return 1;

      // Jika prioritas sama, urutkan berdasarkan tanggal booking (FIFO)
      if (a.bookingDate < b.bookingDate) return -1;
      if (a.bookingDate > b.bookingDate) return 1;
      return 0;
    });

    // ----------------------------------------------------------------------------------------------

    // Membuat Map untuk melacak QTY OK yang tersedia per secondMID
    let qtyOkAvailableMap = {};

    dataSecond.slice(1).forEach((row, index) => {
      const secondMID = row[midSecondIndex].toString().trim();
      const date = formatDate(row[dateSecondIndex]);
      const qtyOk = Number(row[qtyOkSecondIndex]);
      const response = row[responseSecondIndex].toString().trim();

      if (secondMID === '' || date !== today || qtyOk <= 0) {
        return;
      }

      const match = response.match(/Released:\s*(\d+)/i);
      let releasedTotal = 0;
      if (match) {
        releasedTotal = parseInt(match[1], 10);
      }

      const availableToRelease = qtyOk - releasedTotal;
      if (availableToRelease > 0) {
        if (!qtyOkAvailableMap[secondMID]) {
          qtyOkAvailableMap[secondMID] = [];
        }
        qtyOkAvailableMap[secondMID].push({
          rowIndex: index + 2, // +2 karena indeks dimulai dari 0 dan slice dimulai dari 1
          availableBoxes: availableToRelease
        });
      }
    });

    // Pastikan bahwa setiap secondMID memiliki urutan QTY OK berdasarkan rowIndex ascending
    for (const secondMID in qtyOkAvailableMap) {
      qtyOkAvailableMap[secondMID].sort((a, b) => a.rowIndex - b.rowIndex);
    }

    // Iterate melalui semua bookings yang sudah diurutkan berdasarkan prioritas dan tanggal
    for (let i = 0; i < processedBookings.length; i++) {
      const bookingObj = processedBookings[i];
      const bookingRow = bookingObj.data;
      const rowNumber = bookingObj.sheetRowNumber;

      const status = bookingRow[statusIndexBooking];
      if (!status || bookingRow[statusIndexBooking].toString().trim().toLowerCase() !== 'aktif') {
        continue;
      }

      const bookingID = bookingRow[bookingIDIndex];
      const mid = bookingRow[getColumnIndex(bookingsHeaders, 'mid')];
      const lane = bookingRow[getColumnIndex(bookingsHeaders, 'lane')];
      const zona = bookingRow[getColumnIndex(bookingsHeaders, 'zona')];
      let quantityPallet = Number(bookingRow[quantityBookingIndex]);

      if (!mid || !lane) {
        insufficientItems.push({
          bookingID: bookingID || 'Undefined',
          mid: mid || 'Undefined',
          lane: lane || 'Undefined',
          shortage: 'MID atau Lane tidak didefinisikan dalam booking.'
        });
        continue;
      }

      const mappingInfo = MIDMapping[mid];
      if (!mappingInfo) {
        insufficientItems.push({
          bookingID: bookingID || 'Undefined',
          mid: mid,
          lane: lane,
          shortage: 'Converter tidak ditemukan. Pastikan MID terdaftar dengan benar.'
        });
        continue;
      }

      const secondMID = mappingInfo.secondMID;
      const converter = mappingInfo.converter;

      // Verifikasi Pencocokan MID Sebelum Release
      const mainMID = mid;
      const expectedSecondMID = secondMID;

      Logger.log(`Memproses Booking ID: ${bookingID}, Main MID: ${mainMID}, Second MID: ${expectedSecondMID}`);

      // Cek apakah ada QTY OK yang tersedia untuk secondMID ini
      if (!qtyOkAvailableMap[expectedSecondMID] || qtyOkAvailableMap[expectedSecondMID].length === 0) {
        insufficientItems.push({
          bookingID: bookingID || 'Undefined',
          mid: mid,
          lane: lane,
          shortage: 'Tidak ada QTY OK yang tersedia untuk MID ini.'
        });
        continue;
      }

      // Hitung total QTY OK yang tersedia
      let totalBoxesAvailable = qtyOkAvailableMap[expectedSecondMID].reduce((sum, entry) => sum + entry.availableBoxes, 0);

      // Total boxes yang dibutuhkan untuk booking ini
      const totalBoxesNeeded = quantityPallet * converter;

      // Tentukan jumlah boxes yang bisa direlease
      const boxesToRelease = Math.min(totalBoxesNeeded, totalBoxesAvailable);

      if (boxesToRelease <= 0) {
        insufficientItems.push({
          bookingID: bookingID || 'Undefined',
          mid: mid,
          lane: lane,
          shortage: 'QTY OK tidak mencukupi untuk mengurangi Quantity.'
        });
        continue;
      }

      // Mengurangi QTY di sheet utama
      const matchingRowsMain = dataMain.slice(1)
        .map((row, rowIndex) => ({ row, rowIndex }))
        .filter(entry =>
          entry.row[midIndex] === mainMID &&
          entry.row[laneIndex] === lane &&
          Number(entry.row[quantityIndex]) > 0
        )
        .sort((a, b) => {
          const dateA = rowHasDate(a.row, dateIndex) ? parseDate(a.row[dateIndex]) : new Date('9999-12-31');
          const dateB = rowHasDate(b.row, dateIndex) ? parseDate(b.row[dateIndex]) : new Date('9999-12-31');
          return dateA - dateB;
        });

      if (matchingRowsMain.length === 0) {
        insufficientItems.push({
          bookingID: bookingID || 'Undefined',
          mid: mid,
          lane: lane,
          shortage: 'Tidak ada data Quantity di sheet utama untuk dikurangi.'
        });
        continue;
      }

      let remainingBoxesToDeduct = boxesToRelease;

      for (let j = 0; j < matchingRowsMain.length; j++) {
        const entry = matchingRowsMain[j];
        const row = entry.row;
        const rowIndexMain = entry.rowIndex + 2;

        const availableBoxes = Number(row[quantityIndex]) * converter; // Convert pallets to boxes
        const boxesThisRow = Math.min(availableBoxes, remainingBoxesToDeduct);
        const newQuantityBoxes = availableBoxes - boxesThisRow;
        const newQuantityPallets = newQuantityBoxes / converter;

        const roundedNewQuantityPallets = Math.round(newQuantityPallets * 10000) / 10000;
        sheetMain.getRange(rowIndexMain, quantityIndex + 1).setValue(roundedNewQuantityPallets);

        remainingBoxesToDeduct -= boxesThisRow;

        if (remainingBoxesToDeduct <= 0) {
          break;
        }
      }

      // Mengurangi QTY OK di sheet kedua
      let boxesReleased = 0;

      for (let k = 0; k < qtyOkAvailableMap[expectedSecondMID].length; k++) {
        const entry = qtyOkAvailableMap[expectedSecondMID][k];
        if (boxesReleased >= boxesToRelease) {
          break;
        }

        const availableBoxes = entry.availableBoxes;
        const boxesToUseNow = Math.min(availableBoxes, boxesToRelease - boxesReleased);
        const rowIndexSecond = entry.rowIndex;

        // Update 'Released' pada sheet kedua
        const currentResponse = sheetSecond.getRange(rowIndexSecond, responseSecondIndex + 1).getValue().toString().trim();
        let releasedTotal = 0;
        const match = currentResponse.match(/Released:\s*(\d+)/i);
        if (match) {
          releasedTotal = parseInt(match[1], 10);
        }
        releasedTotal += boxesToUseNow;
        sheetSecond.getRange(rowIndexSecond, responseSecondIndex + 1).setValue(`Released: ${releasedTotal}`);

        // Update QTY OK yang tersedia dalam map
        qtyOkAvailableMap[expectedSecondMID][k].availableBoxes -= boxesToUseNow;
        boxesReleased += boxesToUseNow;

        Logger.log(`Released ${boxesToUseNow} boxes for Booking ID: ${bookingID}, Second MID: ${secondMID}`);
      }

      // Menambahkan ke pickingList dan outboundEntries
      if (boxesReleased < totalBoxesNeeded) {
        const remainingBoxesInBooking = totalBoxesNeeded - boxesReleased;
        const remainingPalletsInBooking = remainingBoxesInBooking / converter;

        // Update Quantity (Pallet) pada sheet BOOKINGS
        const newQuantityPallet = Math.round(remainingPalletsInBooking * 10000) / 10000;
        bookingsSheet.getRange(rowNumber, quantityBookingIndex + 1).setValue(newQuantityPallet);

        insufficientItems.push({
          bookingID: bookingID || 'Undefined',
          mid: mid,
          lane: lane,
          shortage: `Quantity belum habis. Sisa Quantity: ${remainingBoxesInBooking} boxes (${newQuantityPallet} pallets).`
        });

        pickingList.push({
          lane: lane,
          zona: zona,
          mid: mid,
          quantity: boxesReleased,
          date: today
        });

        outboundEntries.push([
          bookingID,
          mid,
          lane,
          zona,
          boxesReleased,
          today,
          'Released',
          'Partial'
        ]);
      } else {
        // Full release
        outboundEntries.push([
          bookingID,
          mid,
          lane,
          zona,
          boxesReleased,
          today,
          'Released',
          'Full'
        ]);

        pickingList.push({
          lane: lane,
          zona: zona,
          mid: mid,
          quantity: boxesReleased,
          date: today
        });

        // Update status to 'Rilis' dan hapus booking jika sudah full release
        bookingsSheet.getRange(rowNumber, statusIndexBooking + 1).setValue('Rilis');
        rowsToDelete.push(rowNumber);
      }
    }

    // Memproses Picking List
    let pickingSheet = ssMain.getSheetByName(PICKING_LIST_SHEET_NAME);
    if (!pickingSheet) {
      pickingSheet = ssMain.insertSheet(PICKING_LIST_SHEET_NAME);
      pickingSheet.appendRow(['Lane', 'Zona', 'MID', 'Quantity (Box)', 'Date']);
    } else {
      pickingSheet.clearContents();
      pickingSheet.appendRow(['Lane', 'Zona', 'MID', 'Quantity (Box)', 'Date']);
    }

    pickingList.forEach(item => {
      pickingSheet.appendRow([item.lane, item.zona, item.mid, item.quantity, item.date]);
    });

    // Memproses Outbound Entries
    if (outboundEntries.length > 0) {
      const lastRow = outboundSheet.getLastRow();
      outboundSheet.getRange(lastRow + 1, 1, outboundEntries.length, outboundEntries[0].length).setValues(outboundEntries);
    }

    // Menghapus Booking yang Telah Direlease secara penuh
    rowsToDelete.sort((a, b) => b - a); // Urutkan descending untuk menghindari shift saat menghapus
    rowsToDelete.forEach(rowNum => {
      bookingsSheet.deleteRow(rowNum);
    });

    if (insufficientItems.length > 0) {
      let errorMessage = 'Beberapa booking telah direlease dengan pengurangan partial dan beberapa tidak dapat direlease karena kekurangan stok:\n';
      insufficientItems.forEach(item => {
        errorMessage += `Booking ID: ${item.bookingID}, MID: ${item.mid}, Lane: ${item.lane}, Kekurangan: ${item.shortage}\n`;
      });
      return {
        success: true,
        pickingList: pickingList,
        insufficientItems: insufficientItems,
        message: errorMessage
      };
    }

    return {
      success: true,
      pickingList: pickingList,
      insufficientItems: insufficientItems
    };
  } catch (error) {
    throw new Error(error.message);
  } finally {
    lock.releaseLock();
  }
}



/**
 * Function to get unique MIDs from the main spreadsheet
 * @returns {Array} Array of unique MIDs
 */
function getMIDs() {
  const ss = SpreadsheetApp.openById(MAIN_SPREADSHEET_ID);
  const sheet = ss.getSheetByName(MAIN_SHEET_NAME);
  const dataRange = sheet.getDataRange();
  const data = dataRange.getValues();

  // Assume first row is header
  const headers = data[0];

  const midIndex = getColumnIndex(headers, 'MID');

  if (midIndex === -1) {
    throw new Error('Pastikan sheet memiliki kolom "MID".');
  }

  const mids = data.slice(1).map(row => row[midIndex]).filter(mid => mid && mid.toString().trim() !== '');
  const uniqueMIDs = [...new Set(mids)];
  return uniqueMIDs;
}

/**
 * Function to get unique lanes for a given MID, sorted by FIFO
 * @param {String} mid - Selected MID
 * @returns {Array} Array of lane objects dengan tanggal yang tersedia untuk MID, diurutkan berdasarkan FIFO
 */
function getLanesForMID(mid) {
  const ss = SpreadsheetApp.openById(MAIN_SPREADSHEET_ID);
  const sheet = ss.getSheetByName(MAIN_SHEET_NAME);
  const dataRange = sheet.getDataRange();
  const data = dataRange.getValues();

  // Assume first row is header
  const headers = data[0];

  const laneIndex = getColumnIndex(headers, 'Lane');
  const midIndex = getColumnIndex(headers, 'MID');
  const dateIndex = getColumnIndex(headers, 'Date');
  const quantityIndex = getColumnIndex(headers, 'Quantity');

  if (laneIndex === -1 || midIndex === -1 || dateIndex === -1 || quantityIndex === -1) {
    throw new Error('Pastikan sheet memiliki kolom "Lane", "MID", "Date", dan "Quantity".');
  }

  // Filter rows dengan MID dan Quantity > 0
  const filteredRows = data.slice(1).filter(row => row[midIndex] === mid && Number(row[quantityIndex]) > 0);

  // Sort filtered rows berdasarkan tanggal (FIFO)
  filteredRows.sort((a, b) => {
    const dateA = rowHasDate(a, dateIndex) ? new Date(a[dateIndex]) : new Date('9999-12-31');
    const dateB = rowHasDate(b, dateIndex) ? new Date(b[dateIndex]) : new Date('9999-12-31');
    return dateA - dateB;
  });

  // Create an object to store Lane and the earliest date (FIFO)
  const laneDateMap = {};
  filteredRows.forEach(row => {
    const lane = row[laneIndex];
    const date = row[dateIndex] ? formatDate(row[dateIndex]) : 'N/A';
    if (!laneDateMap[lane]) {
      laneDateMap[lane] = date;
    }
  });

  // Extract unique lanes dengan dates
  const lanesWithDates = Object.keys(laneDateMap).map(lane => ({
    lane: lane,
    date: laneDateMap[lane]
  }));

  return lanesWithDates;
}

/**
 * Function to get the Quantity from the main spreadsheet for booking
 * @param {String} mid - Selected MID
 * @param {String} lane - Selected Lane
 * @returns {Number} Quantity in pallets
 */
function getQuantityFromMainSpreadsheet(mid, lane) {
  const ss = SpreadsheetApp.openById(MAIN_SPREADSHEET_ID);
  const sheet = ss.getSheetByName(MAIN_SHEET_NAME);
  const dataRange = sheet.getDataRange();
  const data = dataRange.getValues();
  const headers = data[0];

  const midIndex = getColumnIndex(headers, 'MID');
  const laneIndex = getColumnIndex(headers, 'Lane');
  const quantityIndex = getColumnIndex(headers, 'Quantity');

  if (midIndex === -1 || laneIndex === -1 || quantityIndex === -1) {
    throw new Error('Pastikan sheet utama memiliki kolom "MID", "Lane", dan "Quantity".');
  }

  // Cari baris yang cocok dengan MID dan Lane
  const matchingRows = data.slice(1).filter(row => 
    row[midIndex] === mid && 
    row[laneIndex] === lane && 
    Number(row[quantityIndex]) > 0
  );

  if (matchingRows.length === 0) {
    return 0;
  }

  // Ambil Quantity dari baris pertama yang cocok
  const quantity = Number(matchingRows[0][quantityIndex]);

  return quantity;
}

/**
 * Helper function to format date to 'dd/MM/yyyy'
 * @param {String|Date} date - Tanggal dalam format string atau Date object
 * @returns {String} Formatted date string
 */
function formatDate(date) {
  if (Object.prototype.toString.call(date) === "[object Date]") {
    // Valid date object
    return Utilities.formatDate(date, Session.getScriptTimeZone(), 'dd/MM/yyyy');
  } else {
    // Assume date is string in some format, try to parse it
    const parsedDate = new Date(date);
    if (!isNaN(parsedDate)) {
      return Utilities.formatDate(parsedDate, Session.getScriptTimeZone(), 'dd/MM/yyyy');
    } else {
      return ''; // Invalid date
    }
  }
}

/**
 * Helper function to check if a row has a date
 * @param {Array} row - Row data
 * @param {Number} dateIndex - Index of the date column
 * @returns {Boolean} - True if the row has a date, false otherwise
 */
function rowHasDate(row, dateIndex) {
  return row[dateIndex] && row[dateIndex].toString().trim() !== '';
}

/**
 * Function to get booking data for the table
 * @returns {Object} Object containing headers and rows
 */
function getBookingData() {
  const ss = SpreadsheetApp.openById(MAIN_SPREADSHEET_ID);
  const bookingsSheet = ss.getSheetByName(BOOKINGS_SHEET_NAME);
  if (!bookingsSheet) {
    return {
      headers: [],
      rows: []
    };
  }

  const data = bookingsSheet.getDataRange().getValues();
  if (data.length === 0) {
    return {
      headers: [],
      rows: []
    };
  }

  const headers = data[0];
  const rows = data.slice(1);

  // Format tanggal (kolom ke-6, indeks 5)
  const formattedRows = rows.map(row => {
    const formattedRow = [...row];
    const dateCell = row[5];
    if (dateCell instanceof Date) {
      // Format tanggal menjadi DD/MM/YYYY
      const day = ("0" + dateCell.getDate()).slice(-2);
      const month = ("0" + (dateCell.getMonth() + 1)).slice(-2);
      const year = dateCell.getFullYear();
      formattedRow[5] = `${day}/${month}/${year}`;
    }
    return formattedRow;
  });

  return {
    headers: headers,
    rows: formattedRows
  };
}






/* TRIAL OUTBOUND FULL PALLET MANUAL */

// **Konstanta untuk Spreadsheet**
const TRIAL_OUTBOUND_SPREADSHEET_ID = '1bH3_loER7TNhomI13gXuuowNA45sIKuO9xbQjw1-WY8';
const TRIAL_OUTBOUND_SHEET_NAME = 'LANE STATUS';
const TRIAL_OUTBOUND_PICKING_LIST_SHEET_NAME = 'PICKING LIST'; // Nama baru sheet Picking List

/**
 * Fungsi untuk mendapatkan indeks kolom dengan ignore case dan trim
 * @param {Array} headers - Array nama kolom
 * @param {String} columnName - Nama kolom yang dicari
 * @returns {Number} - Indeks kolom atau -1 jika tidak ditemukan
 */
function TRIAL_OUTBOUND_getColumnIndex(headers, columnName) {
  for (let i = 0; i < headers.length; i++) {
    if (headers[i].toString().trim().toLowerCase() === columnName.toLowerCase()) {
      return i;
    }
  }
  return -1;
}

/**
 * Fungsi utama untuk memproses outbound menggunakan FIFO dan membuat PICKING LIST
 * Dipanggil dari frontend
 * @param {Array} outboundOrders - Array objek {mid, lane, quantity}
 * @returns {Object} Result object dengan status dan pickingList atau error
 */
function TRIAL_OUTBOUND_processOutboundFIFO(outboundOrders) {
  const ss = SpreadsheetApp.openById(TRIAL_OUTBOUND_SPREADSHEET_ID);
  const sheet = ss.getSheetByName(TRIAL_OUTBOUND_SHEET_NAME);
  
  // Ambil semua data dari sheet
  const dataRange = sheet.getDataRange();
  const data = dataRange.getValues();
  
  // Asumsikan baris pertama adalah header
  const headers = data[0];
  
  const laneIndex = TRIAL_OUTBOUND_getColumnIndex(headers, 'Lane');
  const zonaIndex = TRIAL_OUTBOUND_getColumnIndex(headers, 'Zona');
  const quantityIndex = TRIAL_OUTBOUND_getColumnIndex(headers, 'Quantity');
  const midIndex = TRIAL_OUTBOUND_getColumnIndex(headers, 'MID');
  const dateIndex = TRIAL_OUTBOUND_getColumnIndex(headers, 'Date');
  
  // Log untuk debugging
  Logger.log('Lane Index: ' + laneIndex);
  Logger.log('Zona Index: ' + zonaIndex);
  Logger.log('Quantity Index: ' + quantityIndex);
  Logger.log('MID Index: ' + midIndex);
  Logger.log('Date Index: ' + dateIndex);
  
  if (laneIndex === -1 || zonaIndex === -1 || quantityIndex === -1 || midIndex === -1 || dateIndex === -1) {
    throw new Error('Pastikan sheet memiliki kolom "Lane", "Zona", "Quantity", "MID", dan "Date".');
  }
  
  const pickingList = [];
  const insufficientItems = [];
  const midsToClear = []; // Menyimpan nomor baris yang MID-nya akan dihapus
  
  outboundOrders.forEach(order => {
    const { mid, lane, quantity: orderQuantity } = order;
    let remainingQuantity = orderQuantity;
    
    // Temukan semua baris dengan MID dan Lane yang dipilih, Quantity >0
    const filteredItems = data.slice(1).filter(row => row[midIndex] === mid && row[laneIndex] === lane && row[quantityIndex] > 0)
                              .sort((a, b) => {
                                const dateA = a[dateIndex] ? new Date(a[dateIndex]) : new Date('9999-12-31');
                                const dateB = b[dateIndex] ? new Date(b[dateIndex]) : new Date('9999-12-31');
                                return dateA - dateB;
                              });
    
    if (filteredItems.length === 0) {
      insufficientItems.push({ mid, lane, shortage: remainingQuantity });
      return;
    }
    
    filteredItems.forEach(row => {
      if (remainingQuantity <= 0) return;
      
      const availableQuantity = row[quantityIndex];
      const deductQuantity = Math.min(availableQuantity, remainingQuantity);
      
      // Update Quantity di sheet
      const rowNumber = data.indexOf(row) + 1;
      const newQuantity = availableQuantity - deductQuantity;
      sheet.getRange(rowNumber, quantityIndex + 1).setValue(newQuantity);
      
      // Tambahkan ke PICKING LIST
      pickingList.push({
        lane: row[laneIndex],
        zona: row[zonaIndex],
        mid: mid,
        quantity: deductQuantity,
        date: row[dateIndex] ? Utilities.formatDate(new Date(row[dateIndex]), Session.getScriptTimeZone(), 'yyyy-MM-dd') : 'N/A'
      });
      
      remainingQuantity -= deductQuantity;
      
      // Jika Quantity sudah nol, tandai baris untuk menghapus MID
      if (newQuantity === 0) {
        midsToClear.push(rowNumber);
      }
    });
    
    if (remainingQuantity > 0) {
      insufficientItems.push({ mid, lane, shortage: remainingQuantity });
    }
  });
  
  // Tulis PICKING LIST ke sheet baru atau sheet yang sama
  let pickingSheet = ss.getSheetByName(TRIAL_OUTBOUND_PICKING_LIST_SHEET_NAME);
  if (!pickingSheet) {
    pickingSheet = ss.insertSheet(TRIAL_OUTBOUND_PICKING_LIST_SHEET_NAME);
    pickingSheet.appendRow(['Lane', 'Zona', 'MID', 'Quantity', 'Date']);
  } else {
    pickingSheet.clearContents();
    pickingSheet.appendRow(['Lane', 'Zona', 'MID', 'Quantity', 'Date']);
  }
  
  pickingList.forEach(item => {
    pickingSheet.appendRow([item.lane, item.zona, item.mid, item.quantity, item.date]);
  });
  
  // Hapus data MID pada baris yang Quantity-nya nol
  if (midsToClear.length > 0) {
    midsToClear.forEach(rowNumber => {
      sheet.getRange(rowNumber, midIndex + 1).setValue(''); // Menghapus nilai MID
    });
  }
  
  return {
    success: true,
    pickingList: pickingList,
    insufficientItems: insufficientItems
  };
}

/**
 * Fungsi untuk mengambil daftar unik MID dari spreadsheet
 * Dipanggil dari frontend
 * @returns {Array} Array unik MID
 */
function TRIAL_OUTBOUND_getMIDs() {
  const cache = CacheService.getScriptCache();
  const cachedMIDs = cache.get('uniqueMIDs');
  
  if (cachedMIDs) {
    return JSON.parse(cachedMIDs);
  }
  
  const ss = SpreadsheetApp.openById(TRIAL_OUTBOUND_SPREADSHEET_ID);
  const sheet = ss.getSheetByName(TRIAL_OUTBOUND_SHEET_NAME);
  const dataRange = sheet.getDataRange();
  const data = dataRange.getValues();
  
  // Asumsikan baris pertama adalah header
  const headers = data[0];
  
  const midIndex = TRIAL_OUTBOUND_getColumnIndex(headers, 'MID');
  
  // Log untuk debugging
  Logger.log('MID Index: ' + midIndex);
  
  if (midIndex === -1) {
    throw new Error('Pastikan sheet memiliki kolom "MID".');
  }
  
  const mids = data.slice(1).map(row => row[midIndex]).filter(mid => mid && mid.toString().trim() !== '');
  const uniqueMIDs = [...new Set(mids)];
  
  // Cache the unique MIDs for 10 minutes
  cache.put('uniqueMIDs', JSON.stringify(uniqueMIDs), 600);
  
  return uniqueMIDs;
}

/**
 * Fungsi untuk mengambil daftar unik lanes untuk MID yang diberikan, diurutkan berdasarkan FIFO
 * Dipanggil dari frontend
 * @param {String} mid - MID yang dipilih
 * @returns {Array} Array objek lane dengan tanggal yang tersedia untuk MID tersebut, diurutkan berdasarkan FIFO
 */
function TRIAL_OUTBOUND_getLanesForMID(mid) {
  const cache = CacheService.getScriptCache();
  const cacheKey = `lanesForMID_${mid}`;
  const cachedLanes = cache.get(cacheKey);
  
  if (cachedLanes) {
    return JSON.parse(cachedLanes);
  }
  
  const ss = SpreadsheetApp.openById(TRIAL_OUTBOUND_SPREADSHEET_ID);
  const sheet = ss.getSheetByName(TRIAL_OUTBOUND_SHEET_NAME);
  const dataRange = sheet.getDataRange();
  const data = dataRange.getValues();
  
  // Asumsikan baris pertama adalah header
  const headers = data[0];
  
  const laneIndex = TRIAL_OUTBOUND_getColumnIndex(headers, 'Lane');
  const midIndex = TRIAL_OUTBOUND_getColumnIndex(headers, 'MID');
  const quantityIndex = TRIAL_OUTBOUND_getColumnIndex(headers, 'Quantity');
  const dateIndex = TRIAL_OUTBOUND_getColumnIndex(headers, 'Date');
  
  if (laneIndex === -1 || midIndex === -1 || dateIndex === -1 || quantityIndex === -1) {
    throw new Error('Pastikan sheet memiliki kolom "Lane", "MID", "Quantity", dan "Date".');
  }
  
  // Filter rows dengan MID dan Quantity >0
  const filteredRows = data.slice(1).filter(row => row[midIndex] === mid && row[quantityIndex] > 0);
  
  // Sort berdasarkan Date ascending (FIFO)
  filteredRows.sort((a, b) => {
    const dateA = TRIAL_OUTBOUND_rowHasDate(a, dateIndex) ? new Date(a[dateIndex]) : new Date('9999-12-31');
    const dateB = TRIAL_OUTBOUND_rowHasDate(b, dateIndex) ? new Date(b[dateIndex]) : new Date('9999-12-31');
    return dateA - dateB;
  });
  
  // Membuat objek untuk menyimpan Lane dan tanggal pertama kali muncul (FIFO)
  const laneDateMap = {};
  filteredRows.forEach(row => {
    const lane = row[laneIndex];
    const date = row[dateIndex] ? Utilities.formatDate(new Date(row[dateIndex]), Session.getScriptTimeZone(), 'yyyy-MM-dd') : 'N/A';
    if (!laneDateMap[lane]) {
      laneDateMap[lane] = date;
    }
  });
  
  // Extract unique lanes dengan tanggal
  const lanesWithDates = Object.keys(laneDateMap).map(lane => ({
    lane: lane,
    date: laneDateMap[lane]
  }));
  
  // Cache the lanes for this MID for 10 minutes
  cache.put(cacheKey, JSON.stringify(lanesWithDates), 600);
  
  return lanesWithDates;
}

/**
 * Fungsi untuk mengambil Quantity yang tersedia untuk MID dan Lane tertentu
 * Dipanggil dari frontend
 * @param {String} mid - MID yang dipilih
 * @param {String} lane - Lane yang dipilih
 * @returns {Number} Quantity yang tersedia
 */
function TRIAL_OUTBOUND_getAvailableQuantity(mid, lane) {
  const ss = SpreadsheetApp.openById(TRIAL_OUTBOUND_SPREADSHEET_ID);
  const sheet = ss.getSheetByName(TRIAL_OUTBOUND_SHEET_NAME);
  const dataRange = sheet.getDataRange();
  const data = dataRange.getValues();
  
  // Asumsikan baris pertama adalah header
  const headers = data[0];
  
  const laneIndex = TRIAL_OUTBOUND_getColumnIndex(headers, 'Lane');
  const midIndex = TRIAL_OUTBOUND_getColumnIndex(headers, 'MID');
  const quantityIndex = TRIAL_OUTBOUND_getColumnIndex(headers, 'Quantity');
  
  if (laneIndex === -1 || midIndex === -1 || quantityIndex === -1) {
    throw new Error('Pastikan sheet memiliki kolom "Lane", "MID", dan "Quantity".');
  }
  
  // Cari baris yang sesuai dengan MID dan Lane
  const matchingRows = data.slice(1).filter(row => row[midIndex] === mid && row[laneIndex] === lane);
  
  // Jumlahkan Quantity yang tersedia
  const totalAvailable = matchingRows.reduce((acc, row) => acc + row[quantityIndex], 0);
  
  return totalAvailable;
}

/**
 * Helper function untuk memeriksa apakah baris memiliki tanggal
 * @param {Array} row - Baris data
 * @param {Number} dateIndex - Indeks kolom tanggal
 * @returns {Boolean} - True jika memiliki tanggal, false jika tidak
 */
function TRIAL_OUTBOUND_rowHasDate(row, dateIndex) {
  return row[dateIndex] && row[dateIndex].toString().trim() !== '';
}

/**
 * Fungsi untuk mengembalikan halaman HTML utama
 * @returns {HtmlOutput} Output HTML untuk ditampilkan
 */
function TRIAL_OUTBOUND_getMainPage() {
  return HtmlService.createHtmlOutputFromFile('Index')
    .setTitle('Outbound FMCG')
    .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
}



/* HISTORY OUTBOUND */

// Code.gs

function getOutboundData() {
  return getDataFromSheet('OUTBOUND');
}

function getInboundRawData() {
  return getDataFromSheet('INBOUND RAW');
}

/**
 * General function to retrieve data from a specific sheet.
 * @param {string} sheetName - The name of the sheet to retrieve data from.
 * @returns {Array<Object>} - Array of objects containing the sheet data.
 */
function getDataFromSheet(sheetName) {
  try {
    const spreadsheetId = '1bH3_loER7TNhomI13gXuuowNA45sIKuO9xbQjw1-WY8'; // Replace with your spreadsheet ID
    const ss = SpreadsheetApp.openById(spreadsheetId);
    Logger.log(`Spreadsheet with ID ${spreadsheetId} opened successfully.`);
    
    const sheet = ss.getSheetByName(sheetName);
    if (!sheet) {
      throw new Error(`Sheet "${sheetName}" not found.`);
    }
    Logger.log(`Sheet "${sheetName}" found successfully.`);
    
    const data = sheet.getDataRange().getValues();
    Logger.log(`Data from sheet "${sheetName}" retrieved successfully.`);
    
    if (data.length < 2) {
      Logger.log(`No data rows found in sheet "${sheetName}".`);
      return [];
    }
    
    const headers = data[0];
    Logger.log(`Headers from sheet "${sheetName}": ${JSON.stringify(headers)}`);
    
    const rows = data.slice(1).map(row => {
      let obj = {};
      headers.forEach((header, index) => {
        let cell = row[index];
        
        // Convert each value to string
        if (header === 'Date') {
          if (cell instanceof Date) {
            // Format date as 'dd-mm-yyyy'
            const day = String(cell.getDate()).padStart(2, '0');
            const month = String(cell.getMonth() + 1).padStart(2, '0');
            const year = cell.getFullYear();
            obj[header] = `${day}-${month}-${year}`;
          } else {
            obj[header] = String(cell);
          }
        } else if (header === 'Clock' && sheetName !== 'OUTBOUND') {
          if (cell instanceof Date) {
            // Format time as 'HH:MM:SS'
            const hours = String(cell.getHours()).padStart(2, '0');
            const minutes = String(cell.getMinutes()).padStart(2, '0');
            const seconds = String(cell.getSeconds()).padStart(2, '0');
            obj[header] = `${hours}:${minutes}:${seconds}`;
          } else {
            obj[header] = String(cell);
          }
        } else if (typeof cell === 'number') {
          // Format number as string without decimals
          obj[header] = String(cell);
        } else {
          // If string or other type, convert to string
          obj[header] = String(cell);
        }
      });
      return obj;
    });
    
    Logger.log(`Rows from sheet "${sheetName}": ${JSON.stringify(rows)}`);
    return rows;
  } catch (error) {
    Logger.log(`Error in getDataFromSheet("${sheetName}"): ${error.message}`);
    throw error;
  }
}

/* Builder CLEANUP */


// LaneStatus.gs

// Konstanta untuk ID Spreadsheet dan Nama Sheet Lane Status
const LS_SPREADSHEET_ID = "1bH3_loER7TNhomI13gXuuowNA45sIKuO9xbQjw1-WY8"; // Ganti dengan ID Spreadsheet Anda
const LS_SHEET_NAME = "LANE STATUS";

/**
 * Fungsi untuk mendapatkan data Lane Status dari Spreadsheet.
 * @returns {Array} - Array of records.
 */
function getLaneStatusDataCleanUp() {
  try {
    const ss = SpreadsheetApp.openById(LS_SPREADSHEET_ID);
    const sheet = ss.getSheetByName(LS_SHEET_NAME);
    if (!sheet) throw new Error("Sheet tidak ditemukan.");
    const data = sheet.getDataRange().getValues();
    if (data.length < 2) return [];
    const headers = data[0].map(header => header.toString().trim());
    const records = data.slice(1).map((row, index) => {
      let record = {};
      headers.forEach((header, idx) => {
        let value = row[idx];
        if (header === 'Date' && value instanceof Date) {
          value = Utilities.formatDate(value, Session.getScriptTimeZone(), 'dd-MM-yyyy');
        }
        record[header] = value !== undefined ? value : '';
      });
      record['rowNumber'] = index + 2;
      return record;
    });
    return records;
  } catch (error) {
    Logger.log(error);
    throw error;
  }
}

/**
 * Fungsi untuk memperbarui data Lane Status di Spreadsheet dengan verifikasi kata sandi.
 * @param {number} rowNumber - Nomor baris yang akan diperbarui.
 * @param {Object} updatedData - Data yang akan diperbarui.
 * @param {string} password - Kata sandi admin.
 * @returns {Object} - Objek hasil operasi.
 */
function updateLaneStatusData(rowNumber, updatedData, password) {
  try {
    // Verifikasi kata sandi
    if (!verifyPassword(password)) {
      return { success: false, message: 'Incorrect password. Access denied.' };
    }

    const ss = SpreadsheetApp.openById(LS_SPREADSHEET_ID);
    const sheet = ss.getSheetByName(LS_SHEET_NAME);
    if (!sheet) throw new Error("Sheet tidak ditemukan.");
    const lastRow = sheet.getLastRow();
    if (rowNumber < 2 || rowNumber > lastRow) {
      throw new Error("Nomor baris tidak valid.");
    }
    const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
    const columnIndices = {};
    headers.forEach((header, idx) => {
      columnIndices[header] = idx + 1;
    });

    // Perbarui tanggal jika disediakan
    if (updatedData.Date !== undefined) {
      const dateParts = updatedData.Date.split('-');
      if(dateParts.length !== 3){
        throw new Error("Format tanggal tidak valid.");
      }
      const formattedDate = new Date(`${dateParts[2]}-${dateParts[1]}-${dateParts[0]}`);
      if (isNaN(formattedDate)) {
        throw new Error("Tanggal tidak valid.");
      }
      sheet.getRange(rowNumber, columnIndices['Date']).setValue(formattedDate);
    }

    // Update last run time
    PropertiesService.getScriptProperties().setProperty('lastCleanUpTime', new Date().toISOString());

    return { success: true };
  } catch (error) {
    Logger.log(error);
    return { success: false, message: error.message };
  }
}

/**
 * Fungsi untuk melakukan clean-up data secara otomatis.
 * Membersihkan kolom MID, Setting, dan Date untuk baris dengan Quantity 0.
 * @returns {Object} - Objek hasil operasi.
 */
function cleanUpData() {
  try {
    const ss = SpreadsheetApp.openById(LS_SPREADSHEET_ID);
    const sheet = ss.getSheetByName(LS_SHEET_NAME);
    if (!sheet) throw new Error("Sheet tidak ditemukan.");
    const data = sheet.getDataRange().getValues();
    if (data.length < 2) return { success: true, message: "Tidak ada data untuk dibersihkan." };
    const headers = data[0].map(header => header.toString().trim());
    const quantityIdx = headers.indexOf('Quantity');
    const midIdx = headers.indexOf('MID');
    const settingIdx = headers.indexOf('Setting');
    const dateIdx = headers.indexOf('Date');

    if (quantityIdx === -1 || midIdx === -1 || settingIdx === -1 || dateIdx === -1) {
      throw new Error("Salah satu kolom yang diperlukan tidak ditemukan.");
    }

    let cleanedCount = 0;
    for (let i = 1; i < data.length; i++) {
      const quantity = data[i][quantityIdx];
      if (quantity === 0 || quantity === '0') {
        sheet.getRange(i + 1, midIdx + 1).setValue('');
        sheet.getRange(i + 1, settingIdx + 1).setValue('');
        sheet.getRange(i + 1, dateIdx + 1).setValue('');
        cleanedCount++;
      }
    }

    // Update last run time
    PropertiesService.getScriptProperties().setProperty('lastCleanUpTime', new Date().toISOString());

    return { success: true, message: `Bersih ${cleanedCount} baris.` };
  } catch (error) {
    Logger.log(error);
    return { success: false, message: error.message };
  }
}

/**
 * Fungsi untuk mendapatkan waktu clean-up berikutnya.
 * @returns {string} - Waktu clean-up berikutnya atau informasi jika belum pernah dijalankan.
 */
function getNextCleanUpTime() {
  const scriptProperties = PropertiesService.getScriptProperties();
  const lastRun = scriptProperties.getProperty('lastCleanUpTime');

  if (!lastRun) {
    return "Clean-up belum pernah dijalankan.";
  }

  const lastRunTime = new Date(lastRun);
  const nextRunTime = new Date(lastRunTime.getTime() + 30 * 60 * 1000); // 30 menit setelah terakhir run
  return Utilities.formatDate(nextRunTime, Session.getScriptTimeZone(), 'dd-MM-yyyy HH:mm:ss');
}

/**
 * Fungsi untuk membuat trigger clean-up jika belum ada.
 */
function createCleanUpTrigger() {
  const triggers = ScriptApp.getProjectTriggers();
  const triggerExists = triggers.some(trigger => trigger.getHandlerFunction() === 'cleanUpData' && trigger.getEventType() === ScriptApp.EventType.TIME_BASED);
  if (!triggerExists) {
    ScriptApp.newTrigger('cleanUpData')
      .timeBased()
      .everyMinutes(30)
      .create();
  }
}

